/** This file is part of the ldbc. For the full copyright and license information, please view the LICENSE file that was
  * distributed with this source code.
  */

package ldbc.dsl

import cats.data.Kleisli
import cats.implicits.*

import cats.effect.Sync

import ldbc.sql.*
import ldbc.dsl.logging.{ LogEvent, LogHandler }

/** A class that provides methods to connect to a database and return the retrieved data in an arbitrary form.
  *
  * @param statement
  *   SQL statement string
  * @param params
  *   A list of Traits that generate values from Parameter, allowing PreparedStatement to be set to a value by index
  *   only.
  * @param resultSet
  *   A table of data representing a database result set, which is usually generated by executing a statement that
  *   queries the database.
  * @tparam F
  *   The effect type
  * @tparam T
  *   Data type after retrieving from the database
  */
case class Command[F[_]: Sync, T](
  statement: String,
  params:    Seq[ParameterBinder[F]],
  resultSet: Kleisli[F, ResultSet[F], T]
):

  given Kleisli[F, ResultSet[F], T] = resultSet

  private def connection[A](consumer: ResultSetConsumer[F, A])(using
    logHandler:                       LogHandler[F]
  ): Kleisli[F, Connection[F], A] =
    Kleisli { connection =>
      for
        prepareStatement <- connection.prepareStatement(statement)
        resultSet <- params.zipWithIndex.traverse {
                       case (param, index) => param.bind(prepareStatement, index + 1)
                     } >> prepareStatement
                       .executeQuery()
                       .onError(ex =>
                         logHandler.run(
                           LogEvent.ExecFailure(statement, params.map(_.parameter).toList, ex)
                         )
                       )
        result <-
          consumer
            .consume(resultSet)
            .onError(ex => logHandler.run(LogEvent.ProcessingFailure(statement, params.map(_.parameter).toList, ex)))
            <* prepareStatement.close()
            <* logHandler.run(LogEvent.Success(statement, params.map(_.parameter).toList))
      yield result
    }

  /** Methods for returning an array of data to be retrieved from the database.
    */
  def toList: LogHandler[F] ?=> Kleisli[F, Connection[F], List[T]] =
    connection[List[T]](
      summon[ResultSetConsumer[F, List[T]]]
    )

  /** A method to return the data to be retrieved from the database as Option type. If there are multiple data, the
    * first one is retrieved.
    */
  def headOption: LogHandler[F] ?=> Kleisli[F, Connection[F], Option[T]] =
    connection[Option[T]](
      summon[ResultSetConsumer[F, Option[T]]]
    )

  /** A method to return the data to be retrieved from the database as is. If the data does not exist, an exception is
    * raised. Use the [[headOption]] method if you want to retrieve individual data.
    */
  def unsafe: LogHandler[F] ?=> Kleisli[F, Connection[F], T] =
    connection[T](
      summon[ResultSetConsumer[F, T]]
    )
