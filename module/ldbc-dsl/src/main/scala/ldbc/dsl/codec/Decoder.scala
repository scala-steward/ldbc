/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl.codec

import java.time.*

import scala.deriving.Mirror

import cats.Applicative

import org.typelevel.twiddles.TwiddleSyntax

import ldbc.sql.ResultSet

/**
 * Class to get the DataType that matches the Scala type information from the ResultSet.
 *
 * @tparam A
 *   Scala types that match SQL DataType
 */
trait Decoder[A]:
  self =>

  /**
   * Offset value for the next data to be retrieved from the ResultSet.
   */
  def offset: Int = 1

  /**
   * Method to retrieve data from a ResultSet using an Index number.
   *
   * @param resultSet
   * A table of data representing a database result set, which is usually generated by executing a statement that
   * queries the database.
   * @param index
   * Index number of the data to be retrieved from the ResultSet.
   */
  def decode(resultSet: ResultSet, index: Int): A

  /** Map decoded results to a new type `B`, yielding a `Decoder[B]`. */
  def map[B](f: A => B): Decoder[B] = new Decoder[B]:
    override def offset: Int = self.offset
    override def decode(resultSet: ResultSet, index: Int): B = f(self.decode(resultSet, index))

  /** `Decoder` is semigroupal: a pair of decoders make a decoder for a pair. */
  def product[B](fb: Decoder[B]): Decoder[(A, B)] = new Decoder[(A, B)]:
    override def offset: Int = self.offset + fb.offset
    override def decode(resultSet: ResultSet, index: Int): (A, B) =
      (self.decode(resultSet, index), fb.decode(resultSet, index + self.offset))

  /** Lift this `Decoder` into `Option`. */
  def opt: Decoder[Option[A]] = new Decoder[Option[A]]:
    override def offset: Int = self.offset
    override def decode(resultSet: ResultSet, index: Int): Option[A] =
      val value = self.decode(resultSet, index)
      if resultSet.wasNull() then None else Some(value)

object Decoder extends TwiddleSyntax[Decoder]:

  def apply[A](using decoder: Decoder[A]): Decoder[A] = decoder

  given Applicative[Decoder] with
    override def map[A, B](fa: Decoder[A])(f: A => B): Decoder[B] = fa map f
    override def ap[A, B](fab: Decoder[A => B])(fa: Decoder[A]): Decoder[B] =
      map(fab.product(fa)) { case (fabb, a) => fabb(a) }
    override def pure[A](x: A): Decoder[A] = new Decoder[A]:
      override def offset: Int = 0
      override def decode(resultSet: ResultSet, index: Int): A = x

  given Decoder[String]        = (resultSet: ResultSet, index: Int) => resultSet.getString(index)
  given Decoder[Boolean]       = (resultSet: ResultSet, index: Int) => resultSet.getBoolean(index)
  given Decoder[Byte]          = (resultSet: ResultSet, index: Int) => resultSet.getByte(index)
  given Decoder[Array[Byte]]   = (resultSet: ResultSet, index: Int) => resultSet.getBytes(index)
  given Decoder[Short]         = (resultSet: ResultSet, index: Int) => resultSet.getShort(index)
  given Decoder[Int]           = (resultSet: ResultSet, index: Int) => resultSet.getInt(index)
  given Decoder[Long]          = (resultSet: ResultSet, index: Int) => resultSet.getLong(index)
  given Decoder[Float]         = (resultSet: ResultSet, index: Int) => resultSet.getFloat(index)
  given Decoder[Double]        = (resultSet: ResultSet, index: Int) => resultSet.getDouble(index)
  given Decoder[LocalDate]     = (resultSet: ResultSet, index: Int) => resultSet.getDate(index)
  given Decoder[LocalTime]     = (resultSet: ResultSet, index: Int) => resultSet.getTime(index)
  given Decoder[LocalDateTime] = (resultSet: ResultSet, index: Int) => resultSet.getTimestamp(index)
  given Decoder[BigDecimal]    = (resultSet: ResultSet, index: Int) => resultSet.getBigDecimal(index)

  given (using decoder: Decoder[String]): Decoder[BigInt] =
    decoder.map(str => if str == null then null else BigInt(str))

  given (using decoder: Decoder[Int]): Decoder[Year] =
    decoder.map(int => Year.of(int))

  given (using decoder: Decoder[String]): Decoder[YearMonth] =
    decoder.map(str => YearMonth.parse(str))

  given [A](using decoder: Decoder[A]): Decoder[Option[A]] = decoder.opt

  given [A, B](using da: Decoder[A], db: Decoder[B]): Decoder[(A, B)] =
    da.product(db)

  given [H, T <: Tuple](using dh: Decoder[H], dt: Decoder[T]): Decoder[H *: T] =
    dh.product(dt).map { case (h, t) => h *: t }
    
  given [P <: Product](using mirror: Mirror.ProductOf[P], decoder: Decoder[mirror.MirroredElemTypes]): Decoder[P] =
    decoder.to[P]
