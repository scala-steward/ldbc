/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl.codec

import cats.Applicative

import org.typelevel.twiddles.TwiddleSyntax

import ldbc.sql.ResultSet

/**
 * Trait to get the DataType that matches the Scala type information from the ResultSet.
 *
 * @tparam A
 *   Scala types that match SQL DataType
 */
trait Decoder[A]:
  self =>

  /**
   * Offset value for the next data to be retrieved from the ResultSet.
   */
  def offset: Int = 1

  /**
   * Method to retrieve data from a ResultSet using an Index number.
   *
   * @param resultSet
   * A table of data representing a database result set, which is usually generated by executing a statement that
   * queries the database.
   * @param index
   * Index number of the data to be retrieved from the ResultSet.
   */
  def decode(resultSet: ResultSet, index: Int): A

  /** Map decoded results to a new type `B`, yielding a `Decoder[B]`. */
  def map[B](f: A => B): Decoder[B] = new Decoder[B]:
    override def offset:                                   Int = self.offset
    override def decode(resultSet: ResultSet, index: Int): B   = f(self.decode(resultSet, index))

  /** `Decoder` is semigroupal: a pair of decoders make a decoder for a pair. */
  def product[B](fb: Decoder[B]): Decoder[(A, B)] = new Decoder[(A, B)]:
    override def offset: Int = self.offset + fb.offset
    override def decode(resultSet: ResultSet, index: Int): (A, B) =
      (self.decode(resultSet, index), fb.decode(resultSet, index + self.offset))

  /** Lift this `Decoder` into `Option`. */
  def opt: Decoder[Option[A]] = new Decoder[Option[A]]:
    override def offset: Int = self.offset
    override def decode(resultSet: ResultSet, index: Int): Option[A] =
      val value = self.decode(resultSet, index)
      if resultSet.wasNull() then None else Some(value)

object Decoder extends TwiddleSyntax[Decoder]:

  def apply[A](using decoder: Decoder[A]): Decoder[A] = decoder

  given Applicative[Decoder] with
    override def map[A, B](fa: Decoder[A])(f: A => B): Decoder[B] = fa map f
    override def ap[A, B](fab: Decoder[A => B])(fa: Decoder[A]): Decoder[B] =
      map(fab.product(fa)) { case (fabb, a) => fabb(a) }
    override def pure[A](x: A): Decoder[A] = new Decoder[A]:
      override def offset:                                   Int = 0
      override def decode(resultSet: ResultSet, index: Int): A   = x

  given [A](using codec: Codec[A]): Decoder[A] = codec.asDecoder
