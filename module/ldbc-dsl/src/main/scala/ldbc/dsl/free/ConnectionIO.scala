/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl.free

import scala.concurrent.duration.FiniteDuration

import cats.{~>, Applicative}
import cats.free.Free
import cats.syntax.all.*

import cats.effect.kernel.{CancelScope, Poll, Sync}

import ldbc.sql.*

sealed trait ConnectionOp[A]:
  def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A]

object ConnectionOp:
  final case class Embed[A](e: Embedded[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.embed(e)
  final case class RaiseError[A](e: Throwable) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.raiseError(e)
  final case class HandleErrorWith[A](fa: ConnectionIO[A], f: Throwable => ConnectionIO[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.handleErrorWith(fa)(f)
  case object Monotonic extends ConnectionOp[FiniteDuration]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[FiniteDuration] = v.monotonic
  case object Realtime extends ConnectionOp[FiniteDuration]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[FiniteDuration] = v.realTime
  final case class Suspend[A](hint: Sync.Type, thunk: () => A) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.suspend(hint)(thunk())
  final case class ForceR[A, B](fa: ConnectionIO[A], fb: ConnectionIO[B]) extends ConnectionOp[B]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[B] = v.forceR(fa)(fb)
  final case class Uncancelable[A](body: Poll[ConnectionIO] => ConnectionIO[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.uncancelable(body)
  final case class Poll1[A](poll: Any, fa: ConnectionIO[A]) extends ConnectionOp[A]:
    override def visit[F[_]](v: Visitor[F]): F[A] = v.poll(poll, fa)
  case object Canceled extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.canceled
  final case class OnCancel[A](fa: ConnectionIO[A], fin: ConnectionIO[Unit]) extends ConnectionOp[A]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[A] = v.onCancel(fa, fin)

  final case class CreateStatement() extends ConnectionOp[Statement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Statement[?]] = v.createStatement()
  final case class PrepareStatement(sql: String) extends ConnectionOp[PreparedStatement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[PreparedStatement[?]] = v.prepareStatement(sql)
  final case class SetAutoCommit(autoCommit: Boolean) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.setAutoCommit(autoCommit)
  case object Commit extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.commit()
  case object Rollback extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.rollback()
  case object Close extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.close()
  final case class SetReadOnly(isReadOnly: Boolean) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] = v.setReadOnly(isReadOnly)
  final case class PrepareStatementWithParams(
    sql: String,
    resultSetType: Int,
    resultSetConcurrency: Int
  ) extends ConnectionOp[PreparedStatement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[PreparedStatement[?]] =
      v.prepareStatement(sql, resultSetType, resultSetConcurrency)
  final case class PrepareStatementWithAutoGeneratedKeys(
    sql: String,
    autoGeneratedKeys: Int
  ) extends ConnectionOp[PreparedStatement[?]]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[PreparedStatement[?]] =
      v.prepareStatement(sql, autoGeneratedKeys)
  final case class SetSavepoint() extends ConnectionOp[Savepoint]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Savepoint] =
      v.setSavepoint()
  final case class SetSavepointWithName(name: String) extends ConnectionOp[Savepoint]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Savepoint] =
      v.setSavepoint(name)
  final case class RollbackToSavepoint(savepoint: Savepoint) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] =
      v.rollback(savepoint)
  final case class ReleaseSavepoint(savepoint: Savepoint) extends ConnectionOp[Unit]:
    override def visit[F[_]](v: ConnectionOp.Visitor[F]): F[Unit] =
      v.releaseSavepoint(savepoint)

  given [F[_]]: Embeddable[ConnectionOp, Connection[F]] =
    new Embeddable[ConnectionOp, Connection[F]]:
      override def embed[A](j: Connection[F], fa: Free[ConnectionOp, A]): Embedded.Connection[F, A] = Embedded.Connection(j, fa)

  trait Visitor[F[_]] extends (ConnectionOp ~> F):
    final def apply[A](fa: ConnectionOp[A]): F[A] = fa.visit(this)

    def embed[A](e: Embedded[A]): F[A]
    def handleErrorWith[A](fa: ConnectionIO[A])(f: Throwable => ConnectionIO[A]): F[A]
    def raiseError[A](err: Throwable): F[A]
    def monotonic: F[FiniteDuration]
    def realTime: F[FiniteDuration]
    def suspend[A](hint: Sync.Type)(thunk: => A): F[A]
    def forceR[A, B](fa: ConnectionIO[A])(fb: ConnectionIO[B]): F[B]
    def uncancelable[A](body: Poll[ConnectionIO] => ConnectionIO[A]): F[A]
    def poll[A](poll: Any, fa: ConnectionIO[A]): F[A]
    def canceled: F[Unit]
    def onCancel[A](fa: ConnectionIO[A], fin: ConnectionIO[Unit]): F[A]

    def createStatement(): F[Statement[?]]
    def prepareStatement(sql: String): F[PreparedStatement[?]]
    def setAutoCommit(autoCommit: Boolean): F[Unit]
    def commit(): F[Unit]
    def rollback(): F[Unit]
    def close(): F[Unit]
    def setReadOnly(isReadOnly: Boolean): F[Unit]
    def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): F[PreparedStatement[?]]
    def prepareStatement(
                          sql: String,
                          autoGeneratedKeys: Int
                        ): F[PreparedStatement[?]]
    def setSavepoint(): F[Savepoint]
    def setSavepoint(name: String): F[Savepoint]
    def rollback(savepoint: Savepoint): F[Unit]
    def releaseSavepoint(savepoint: Savepoint): F[Unit]
    
type ConnectionIO[A] = Free[ConnectionOp, A]

object ConnectionIO:
  module =>

  private[ldbc] class Ops[A](connectionIO: ConnectionIO[A]):

    def run[F[_]: Sync](connection: Connection[F]): F[A] =
      connectionIO.foldMap(new KleisliInterpreter[F].ConnectionInterpreter)
        .run(connection)

    def readOnly[F[_]: Sync](connection: Connection[F]): F[A] =
      (ConnectionIO.setReadOnly(true) *> connectionIO <* ConnectionIO.setReadOnly(false))
        .foldMap(new KleisliInterpreter[F].ConnectionInterpreter)
        .run(connection)

    def commit[F[_] : Sync](connection: Connection[F]): F[A] =
      (ConnectionIO.setReadOnly(false) *> ConnectionIO.setAutoCommit(false) *> connectionIO)
        .foldMap(new KleisliInterpreter[F].ConnectionInterpreter)
        .run(connection)

    def rollback[F[_] : Sync](connection: Connection[F]): F[A] =
      (ConnectionIO.setReadOnly(false) *> ConnectionIO.setAutoCommit(false) *> connectionIO <* ConnectionIO.rollback() <* ConnectionIO.setAutoCommit(true))
        .foldMap(new KleisliInterpreter[F].ConnectionInterpreter)
        .run(connection)

    def transaction[F[_] : Sync](connection: Connection[F]): F[A] =
      val interpreter = new KleisliInterpreter[F].ConnectionInterpreter
      val acquire: ConnectionIO[A] = ConnectionIO.setReadOnly(false) *> ConnectionIO.setAutoCommit(false) *> connectionIO

      val release = (_: A, exitCode: cats.effect.kernel.Resource.ExitCase) =>
        (exitCode match
          case cats.effect.kernel.Resource.ExitCase.Errored(_) | cats.effect.kernel.Resource.ExitCase.Canceled => ConnectionIO.rollback()
          case _ => ConnectionIO.commit()
        ) *> ConnectionIO.setAutoCommit(true)

      cats.effect.kernel.Resource
        .makeCase(acquire)(release)
        .use(ConnectionIO.pure)
        .foldMap(interpreter)
        .run(connection)
  
  implicit val syncConnectionIO: Sync[ConnectionIO] =
    new Sync[ConnectionIO]:
      val monad = Free.catsFreeMonadForFree[ConnectionOp]
      override val applicative: Applicative[ConnectionIO] = monad
      override val rootCancelScope: CancelScope = CancelScope.Cancelable
      override def pure[A](x: A): ConnectionIO[A] = monad.pure(x)
      override def flatMap[A, B](fa: ConnectionIO[A])(f: A => ConnectionIO[B]): ConnectionIO[B] = monad.flatMap(fa)(f)
      override def tailRecM[A, B](a: A)(f: A => ConnectionIO[Either[A, B]]): ConnectionIO[B] = monad.tailRecM(a)(f)
      override def raiseError[A](e: Throwable): ConnectionIO[A] = module.raiseError(e)
      override def handleErrorWith[A](fa: ConnectionIO[A])(f: Throwable => ConnectionIO[A]): ConnectionIO[A] = module.handleErrorWith(fa)(f)
      override def monotonic: ConnectionIO[FiniteDuration] = module.monotonic
      override def realTime: ConnectionIO[FiniteDuration] = module.realtime
      override def suspend[A](hint: Sync.Type)(thunk: => A): ConnectionIO[A] = module.suspend(hint)(thunk)
      override def forceR[A, B](fa: ConnectionIO[A])(fb: ConnectionIO[B]): ConnectionIO[B] = module.forceR(fa)(fb)
      override def uncancelable[A](body: Poll[ConnectionIO] => ConnectionIO[A]): ConnectionIO[A] = module.uncancelable(body)
      override def canceled: ConnectionIO[Unit] = module.canceled
      override def onCancel[A](fa: ConnectionIO[A], fin: ConnectionIO[Unit]): ConnectionIO[A] = module.onCancel(fa, fin)

  def embed[F[_], J, A](j: J, fa: Free[F, A])(using ev: Embeddable[F, J]): Free[ConnectionOp, A] =
    Free.liftF(ConnectionOp.Embed(ev.embed(j, fa)))
  def pure[A](a: A): ConnectionIO[A] = Free.pure(a)
  def raiseError[A](err: Throwable): ConnectionIO[A] = Free.liftF(ConnectionOp.RaiseError(err))
  def handleErrorWith[A](fa: ConnectionIO[A])(f: Throwable => ConnectionIO[A]): ConnectionIO[A] =
    Free.liftF[ConnectionOp, A](ConnectionOp.HandleErrorWith(fa, f))
  val monotonic: ConnectionIO[FiniteDuration] = Free.liftF[ConnectionOp, FiniteDuration](ConnectionOp.Monotonic)
  val realtime: ConnectionIO[FiniteDuration] = Free.liftF[ConnectionOp, FiniteDuration](ConnectionOp.Realtime)
  def suspend[A](hint: Sync.Type)(thunk: => A): ConnectionIO[A] = Free.liftF[ConnectionOp, A](ConnectionOp.Suspend(hint, () => thunk))
  def forceR[A, B](fa: ConnectionIO[A])(fb: ConnectionIO[B]): ConnectionIO[B] = Free.liftF[ConnectionOp, B](ConnectionOp.ForceR(fa, fb))
  def uncancelable[A](body: Poll[ConnectionIO] => ConnectionIO[A]): ConnectionIO[A] = Free.liftF[ConnectionOp, A](ConnectionOp.Uncancelable(body))
  val canceled: ConnectionIO[Unit] = Free.liftF[ConnectionOp, Unit](ConnectionOp.Canceled)
  def onCancel[A](fa: ConnectionIO[A], fin: ConnectionIO[Unit]): ConnectionIO[A] = Free.liftF[ConnectionOp, A](ConnectionOp.OnCancel(fa, fin))
  def capturePoll[M[_]](mpoll: Poll[M]): Poll[ConnectionIO] = new Poll[ConnectionIO]:
    override def apply[A](fa: ConnectionIO[A]): ConnectionIO[A] = Free.liftF[ConnectionOp, A](ConnectionOp.Poll1(mpoll, fa))

  def createStatement(): ConnectionIO[Statement[?]] =
    Free.liftF[ConnectionOp, Statement[?]](ConnectionOp.CreateStatement())
  def prepareStatement(sql: String): ConnectionIO[PreparedStatement[?]] =
    Free.liftF[ConnectionOp, PreparedStatement[?]](ConnectionOp.PrepareStatement(sql))
  def setAutoCommit(autoCommit: Boolean): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.SetAutoCommit(autoCommit))
  def commit(): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.Commit)
  def rollback(): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.Rollback)
  def close(): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.Close)
  def setReadOnly(isReadOnly: Boolean): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.SetReadOnly(isReadOnly))
  def prepareStatement(
    sql: String,
    resultSetType: Int,
    resultSetConcurrency: Int
  ): ConnectionIO[PreparedStatement[?]] =
    Free.liftF[ConnectionOp, PreparedStatement[?]](ConnectionOp.PrepareStatementWithParams(sql, resultSetType, resultSetConcurrency))
  def prepareStatement(
    sql: String,
    autoGeneratedKeys: Int
  ): ConnectionIO[PreparedStatement[?]] =
    Free.liftF[ConnectionOp, PreparedStatement[?]](ConnectionOp.PrepareStatementWithAutoGeneratedKeys(sql, autoGeneratedKeys))
  def setSavepoint(): ConnectionIO[Savepoint] =
    Free.liftF[ConnectionOp, Savepoint](ConnectionOp.SetSavepoint())
  def setSavepoint(name: String): ConnectionIO[Savepoint] =
    Free.liftF[ConnectionOp, Savepoint](ConnectionOp.SetSavepointWithName(name))
  def rollback(savepoint: Savepoint): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.RollbackToSavepoint(savepoint))
  def releaseSavepoint(savepoint: Savepoint): ConnectionIO[Unit] =
    Free.liftF[ConnectionOp, Unit](ConnectionOp.ReleaseSavepoint(savepoint))
