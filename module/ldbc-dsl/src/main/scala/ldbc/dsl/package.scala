/** This file is part of the ldbc. For the full copyright and license information, please view the LICENSE file that was
  * distributed with this source code.
  */

package ldbc

import javax.sql.DataSource

import scala.deriving.Mirror

import cats.data.Kleisli
import cats.implicits.*

import cats.effect.{ IO, Resource, Sync }
import cats.effect.kernel.Resource.ExitCase

import ldbc.core.Database as CoreDatabase
import ldbc.sql.*
import ldbc.dsl.syntax.*
import ldbc.dsl.logging.{ LogEvent, LogHandler }

package object dsl:

  private trait SyncSyntax[F[_]: Sync]
    extends SQLSyntax[F],
            ConnectionSyntax[F],
            QuerySyntax[F],
            CommandSyntax[F],
            DatabaseSyntax[F]:

    implicit class SqlOps(sql: SQL[F]):
      inline def query[T <: Tuple]: Command[F, T] =
        Command(
          sql.statement,
          sql.params,
          Kleisli { resultSet =>
            ResultSetReader
              .fold[F, T]
              .toList
              .zipWithIndex
              .traverse {
                case (reader, index) => reader.asInstanceOf[ResultSetReader[F, Any]].read(resultSet, index + 1)
              }
              .map(list => Tuple.fromArray(list.toArray).asInstanceOf[T])
          }
        )

      inline def query[P <: Product](using mirror: Mirror.ProductOf[P]): Command[F, P] =
        Command(
          sql.statement,
          sql.params,
          Kleisli { resultSet =>
            ResultSetReader
              .fold[F, mirror.MirroredElemTypes]
              .toList
              .zipWithIndex
              .traverse {
                case (reader, index) => reader.asInstanceOf[ResultSetReader[F, Any]].read(resultSet, index + 1)
              }
              .map(list => mirror.fromProduct(Tuple.fromArray(list.toArray)))
          }
        )

      def update(using logHandler: LogHandler[F]): Kleisli[F, Connection[F], Int] = Kleisli { connection =>
        (for
          statement <- connection.prepareStatement(sql.statement)
          result <- sql.params.zipWithIndex.traverse {
                      case (param, index) => param.bind(statement, index + 1)
                    } >> statement.executeUpdate() <* statement.close()
        yield result)
          .onError(ex => logHandler.run(LogEvent.ExecFailure(sql.statement, sql.params.map(_.parameter).toList, ex)))
          <* logHandler.run(LogEvent.Success(sql.statement, sql.params.map(_.parameter).toList))
      }

      def updateReturningAutoGeneratedKey[T](using
        logHandler: LogHandler[F],
        reader:     ResultSetReader[F, T]
      ): Kleisli[F, Connection[F], T] = Kleisli { connection =>
        given Kleisli[F, ResultSet[F], T] = Kleisli { resultSet =>
          reader.read(resultSet, 1)
        }
        (for
          statement <- connection.prepareStatement(sql.statement, Statement.Generated.RETURN_GENERATED_KEYS)
          resultSet <- sql.params.zipWithIndex.traverse {
                         case (param, index) => param.bind(statement, index + 1)
                       } >> statement.executeUpdate() >> statement.getGeneratedKeys()
          result <- summon[ResultSetConsumer[F, T]].consume(resultSet) <* statement.close()
        yield result)
          .onError(ex => logHandler.run(LogEvent.ExecFailure(sql.statement, sql.params.map(_.parameter).toList, ex)))
          <* logHandler.run(LogEvent.Success(sql.statement, sql.params.map(_.parameter).toList))
      }

    private def buildConnectionResource(acquire: F[Connection[F]]): Resource[F, Connection[F]] =
      val release: Connection[F] => F[Unit] = connection => connection.close()
      Resource.make(acquire)(release)

    extension [T](connectionKleisli: Kleisli[F, Connection[F], T])

      def readOnly: Kleisli[F, DataSource, T] = Kleisli { dataSource =>
        buildConnectionResource {
          for
            connection <- Sync[F].blocking(dataSource.getConnection).map(ConnectionIO[F])
            _          <- connection.setReadOnly(true)
          yield connection
        }
          .use(connectionKleisli.run)
      }

      def autoCommit: Kleisli[F, DataSource, T] = Kleisli { dataSource =>
        buildConnectionResource {
          for
            connection <- Sync[F].blocking(dataSource.getConnection).map(ConnectionIO[F])
            _          <- connection.setReadOnly(false) >> connection.setAutoCommit(true)
          yield connection
        }
          .use(connectionKleisli.run)
      }

      def transaction: Kleisli[F, DataSource, T] = Kleisli { dataSource =>
        (for
          connection <- buildConnectionResource {
                          for
                            connection <- Sync[F].blocking(dataSource.getConnection).map(ConnectionIO[F])
                            _          <- connection.setReadOnly(false) >> connection.setAutoCommit(false)
                          yield connection
                        }
          transact <- Resource.makeCase(Sync[F].pure(connection)) {
                        case (conn, ExitCase.Errored(e)) => conn.rollback() >> Sync[F].raiseError(e)
                        case (conn, _)                   => conn.commit()
                      }
        yield transact).use(connectionKleisli.run)
      }

    extension (database: CoreDatabase)

      def fromDriverManager(): Database[F] =
        Database.fromDriverManager[F](database.databaseType, database.name, database.host, database.port, None, None)

      def fromDriverManager(
        user:     String,
        password: String
      ): Database[F] =
        Database.fromDriverManager[F](
          database.databaseType,
          database.name,
          database.host,
          database.port,
          Some(user),
          Some(password)
        )

      def fromDataSource(dataSource: DataSource): Database[F] =
        Database.fromDataSource[F](database.databaseType, database.name, database.host, database.port, dataSource)

  val io: SyncSyntax[IO] = new SyncSyntax[IO] {}
