/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.dsl

import cats.*
import cats.data.NonEmptyList
import cats.syntax.all.*

import ldbc.sql.ResultSet

import ldbc.dsl.codec.Decoder
import ldbc.dsl.exception.UnexpectedEnd
import ldbc.dsl.free.ResultSetIO
import ldbc.dsl.free.ResultSetIO.*
import ldbc.dsl.util.FactoryCompat

/**
 * Trait for generating the specified data type from a ResultSet.
 *
 * @tparam F
 *   The effect type
 * @tparam T
 *   Type you want to build with data obtained from ResultSet
 */
trait ResultSetConsumer[F[_], T]:

  /**
   * Method for generating the specified data type from a ResultSet.
   *
   * @param resultSet
   *   A table of data representing a database result set, which is usually generated by executing a statement that
   *   queries the database.
   * @param statement
   *   Statement that configured the ResultSet
   * @return
   *   Type you want to build with data obtained from ResultSet
   */
  def consume(resultSet: ResultSet[F], statement: String): F[T]

object ResultSetConsumer:

  private val FIRST_OFFSET = 1

  def consume[F[_]: MonadThrow, T: Decoder, G[_]](
    resultSet:     ResultSet[F],
    statement:     String,
    factoryCompat: FactoryCompat[T, G[T]]
  ): F[G[T]] =
    given FactoryCompat[T, G[T]] = factoryCompat
    summon[ResultSetConsumer[F, G[T]]].consume(resultSet, statement)

  def consumeToNel[F[_]: MonadThrow, T: Decoder](
    resultSet: ResultSet[F],
    statement: String
  ): F[NonEmptyList[T]] =
    summon[ResultSetConsumer[F, List[T]]]
      .consume(resultSet, statement)
      .flatMap { results =>
        if results.isEmpty then MonadThrow[F].raiseError(new UnexpectedEnd("No results found"))
        else MonadThrow[F].pure(NonEmptyList.fromListUnsafe(results))
      }

  given [F[_], T](using
    consumer: ResultSetConsumer[F, Option[T]],
    ev:       MonadThrow[F]
  ): ResultSetConsumer[F, T] with
    override def consume(resultSet: ResultSet[F], statement: String): F[T] =
      consumer.consume(resultSet, statement).flatMap {
        case Some(value) => ev.pure(value)
        case None        => ev.raiseError(new NoSuchElementException(""))
      }

  given [F[_], T](using decoder: Decoder[T], ev: MonadThrow[F]): ResultSetConsumer[F, Option[T]] with
    override def consume(resultSet: ResultSet[F], statement: String): F[Option[T]] =
      resultSet.next().flatMap {
        case true =>
          decoder.decode(FIRST_OFFSET, statement).foldMap(resultSet.interpreter).map(Option(_))
        case false => ev.pure(None)
      }

  given [F[_], T, G[_]](using
    decoder:       Decoder[T],
    factoryCompat: FactoryCompat[T, G[T]]
  )(using ev: MonadThrow[F]): ResultSetConsumer[F, G[T]] with
    override def consume(resultSet: ResultSet[F], statement: String): F[G[T]] =
      val builder = factoryCompat.newBuilder

      def loop(acc: collection.mutable.Builder[T, G[T]]): ResultSetIO[collection.mutable.Builder[T, G[T]]] =
        ResultSetIO.next().flatMap {
          case true  => decoder.decode(FIRST_OFFSET, statement).flatMap(v => loop(acc += v))
          case false => ResultSetIO.pure(acc)
        }

      loop(builder).map(_.result()).foldMap(resultSet.interpreter)
