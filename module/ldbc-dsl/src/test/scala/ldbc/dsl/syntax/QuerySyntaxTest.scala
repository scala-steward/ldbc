/** This file is part of the ldbc. For the full copyright and license information, please view the LICENSE file that was
  * distributed with this source code.
  */

package ldbc.dsl.syntax

import org.scalatest.flatspec.AnyFlatSpec

class QuerySyntaxTest extends AnyFlatSpec:

  it should "It can be converted to the model specified by the toList method." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |val query = user.selectAll.query[User].toList
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the toList method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.query[FailedUser].toList
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the toList method matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |val query: Kleisli[IO, Connection[IO], List[(Long, String, Int)]] = user.selectAll.query.toList
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the headOption method." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |val query = user.selectAll.where(_.id === 1).query[User].headOption
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the headOption method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.where(_.id === 1).query[FailedUser].headOption
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the headOption method matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |val query: Kleisli[IO, Connection[IO], Option[(Long, String, Int)]] = user.selectAll.where(_.id === 1).query.headOption
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the unsafe method." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |val query: Kleisli[IO, Connection[IO], User] = user.selectAll.where(_.id === 1).query[User].unsafe
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the unsafe method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.where(_.id === 1).query[FailedUser].unsafe
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the unsafe method matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT)
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |val query: Kleisli[IO, Connection[IO], (Long, String, Int)] = user.selectAll.where(_.id === 1).query.unsafe
        |""".stripMargin
    )
  }

  it should "The type of the Tuple generated by the Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT),
        |    column("categoryId", BIGINT)
        |  )
        |
        |case class Category(id: Long, name: String)
        |object Category:
        |  val table = Table[Category]("category")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255))
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |val category = TableQuery[IO, Category](Category.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |
        |case class UserCategory(userName: String, categoryName: String)
        |
        |val query: Kleisli[IO, Connection[IO], List[(String, String)]] = (user join category).on((user, category) => user.categoryId === category.id)
        |  .select((user, category) => (user.name, category.name))
        |  .query
        |  .toList
        |""".stripMargin
    )
  }

  it should "The type generated by the join matches the type of the specified model." in {
    assertCompiles(
      """
        |import cats.data.Kleisli
        |import cats.effect.IO
        |
        |import ldbc.core.*
        |import ldbc.sql.Connection
        |import ldbc.dsl.io.{ *, given }
        |import ldbc.dsl.logging.LogHandler
        |import ldbc.query.builder.TableQuery
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long)
        |object User:
        |  val table = Table[User]("user")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255)),
        |    column("age", INT),
        |    column("categoryId", BIGINT)
        |  )
        |
        |case class Category(id: Long, name: String)
        |object Category:
        |  val table = Table[Category]("category")(
        |    column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY),
        |    column("name", VARCHAR(255))
        |  )
        |
        |val user = TableQuery[IO, User](User.table)
        |val category = TableQuery[IO, Category](Category.table)
        |
        |given LogHandler[IO] = LogHandler.consoleLogger
        |
        |case class UserCategory(userName: String, categoryName: String)
        |
        |val query = (user join category).on((user, category) => user.categoryId === category.id)
        |  .select((user, category) => (user.name, category.name))
        |  .query[UserCategory]
        |  .toList
        |""".stripMargin
    )
  }
