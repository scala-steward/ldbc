/**
 * Copyright (c) 2023-2024 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.query.builder

import org.scalatest.flatspec.AnyFlatSpec

class QuerySyntaxTest extends AnyFlatSpec:

  it should "It can be converted to the model specified by the toList method." in {
    assertCompiles(
      """
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |val query = user.selectAll.queryTo[User].to[List]
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the toList method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.queryTo[FailedUser].to[List]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the toList method matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |val query: Executor[IO, List[(Long, String, Int)]] = user.selectAll.query.to[List]
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the headOption method." in {
    assertCompiles(
      """
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |val query = user.selectAll.where(_.id === 1).queryTo[User].to[Option]
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the headOption method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.where(_.id === 1).queryTo[FailedUser].to[Option]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the headOption method matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |val query: Executor[IO, Option[(Long, String, Int)]] = user.selectAll.where(_.id === 1).query.to[Option]
        |""".stripMargin
    )
  }

  it should "It can be converted to the model specified by the unsafe method." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |val query: Executor[IO, User] = user.selectAll.where(_.id === 1).queryTo[User].unsafe
        |""".stripMargin
    )
  }

  it should "If the Tuple generated by the unsafe method does not match the type of the specified model property, a Compile error occurs." in {
    assertDoesNotCompile(
      """
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |case class FailedUser(id: Long, name: String, age: Option[Int])
        |val query = user.selectAll.where(_.id === 1).query[FailedUser].unsafe
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by the unsafe method matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int) derives Table
        |
        |val user = Table[User]
        |
        |val query: Executor[IO, (Long, String, Int)] = user.selectAll.where(_.id === 1).query.unsafe
        |""".stripMargin
    )
  }

  it should "The type of the Tuple generated by the Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long) derives Table
        |
        |case class Category(id: Long, name: String) derives Table
        |
        |val user = Table[User]
        |val category = Table[Category]
        |
        |case class UserCategory(userName: String, categoryName: String)
        |
        |val query: Executor[IO, List[(String, String)]] = (user join category)((user, category) => user.categoryId === category.id)
        |  .select((user, category) => (user.name, category.name))
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "The type generated by the join matches the type of the specified model." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class User(id: Long, name: String, age: Int, categoryId: Long) derives Table
        |
        |case class Category(id: Long, name: String) derives Table
        |
        |val user = Table[User]
        |val category = Table[Category]
        |
        |case class UserCategory(userName: String, categoryName: String)
        |
        |val query = (user join category)((user, category) => user.categoryId === category.id)
        |  .select((user, category) => (user.name, category.name))
        |  .queryTo[UserCategory]
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by Left Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class Country(code: String, name: String) derives Table
        |
        |case class City(id: Long, name: String, countryCode: String) derives Table
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    String
        |) derives Table
        |
        |val countryQuery = Table[Country]
        |val cityQuery = Table[City]
        |val countryLanguageQuery = Table[CountryLanguage]
        |
        |val query: Executor[IO, List[(String, String, Option[String])]] = (countryQuery join cityQuery)((country, city) => country.code === city.countryCode)
        |  .leftJoin(countryLanguageQuery)((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => (country.name, city.name, countryLanguage.language))
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "The type of Tuple generated by Right Join matches the specified type." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class Country(code: String, name: String) derives Table
        |
        |case class City(id: Long, name: String, countryCode: String) derives Table
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    String
        |) derives Table
        |
        |val countryQuery = Table[Country]
        |val cityQuery = Table[City]
        |val countryLanguageQuery = Table[CountryLanguage]
        |
        |val query: Executor[IO, List[(Option[String], Option[String], String)]] = (countryQuery join cityQuery)((country, city) => country.code === city.countryCode)
        |  .rightJoin(countryLanguageQuery)((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => (country.name, city.name, countryLanguage.language))
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }

  it should "When a column of type Option is made into type Option with Right Join, Option is not nested." in {
    assertCompiles(
      """
        |import cats.effect.IO
        |
        |import ldbc.dsl.Executor
        |import ldbc.query.builder.Table
        |import ldbc.query.builder.syntax.io.*
        |
        |case class Country(code: String, name: String) derives Table
        |
        |case class City(id: Long, name: String, countryCode: String) derives Table
        |
        |case class CountryLanguage(
        |  countryCode: String,
        |  language:    Option[String]
        |) derives Table
        |
        |val countryQuery = Table[Country]
        |val cityQuery = Table[City]
        |val countryLanguageQuery = Table[CountryLanguage]
        |
        |val query: Executor[IO, List[(String, String, Option[String])]] = (countryQuery join cityQuery)((country, city) => country.code === city.countryCode)
        |  .leftJoin(countryLanguageQuery)((_, city, countryLanguage) => city.countryCode === countryLanguage.countryCode)
        |  .select((country, city, countryLanguage) => (country.name, city.name, countryLanguage.language))
        |  .query
        |  .to[List]
        |""".stripMargin
    )
  }
