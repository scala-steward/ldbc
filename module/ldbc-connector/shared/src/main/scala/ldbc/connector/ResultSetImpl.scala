/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector

import java.time.*
import java.time.format.DateTimeFormatter
import java.time.temporal.TemporalAccessor

import scala.util.Try

import cats.MonadThrow
import cats.syntax.all.*

import cats.effect.Ref

import ldbc.sql.{ ResultSet, ResultSetMetaData }

import ldbc.connector.data.Formatter.*
import ldbc.connector.exception.SQLException
import ldbc.connector.net.packet.response.*
import ldbc.connector.util.Version
import ldbc.connector.net.Protocol

/**
 * A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
 */
private[ldbc] case class ResultSetImpl[F[_]](
  protocol: Protocol[F],
  columns:              Vector[ColumnDefinitionPacket],
  records:              Vector[ResultSetRowPacket],
  serverVariables:      Map[String, String],
  version:              Version,
  isClosed:            Ref[F, Boolean],
  lastColumnReadNullable: Ref[F, Boolean],
  currentCursor:       Ref[F, Int],
  currentRow:          Ref[F, Option[ResultSetRowPacket]],
  fetchSize: Ref[F, Long],
  useCursorFetch: Ref[F, Boolean],
  useServerPrepStmts: Ref[F, Boolean],
  resultSetType:        Int            = ResultSet.TYPE_FORWARD_ONLY,
  resultSetConcurrency: Int            = ResultSet.CONCUR_READ_ONLY,
  statement:            Option[String] = None
)(using ev: MonadThrow[F]) extends ResultSet[F]:

  //private final val recordSize:             Int                        = records.size
  //private final var isClosed:               Boolean                    = false
  //private final var lastColumnReadNullable: Boolean                    = false
  //private final var currentCursor:          Int                        = 0
  //private final var currentRow:             Option[ResultSetRowPacket] = records.headOption

  override def next(): F[Boolean] =
    checkClosed() *> currentCursor.get.flatMap { cursor =>
      if cursor < records.size then
        currentRow.set(records.lift(cursor)) *>
          currentCursor.update(_ + 1) *>
          currentRow.get.map(_.isDefined)
      else currentCursor.update(_ + 1).as(false)
    }

  override def close(): F[Unit] = isClosed.set(true)

  override def wasNull(): F[Boolean] = lastColumnReadNullable.get

  override def getString(columnIndex: Int): F[String] =
    checkClosed() *> rowDecode[String](columnIndex, str => Right(str)).flatMap {
      case None => lastColumnReadNullable.set(true) *> ev.pure(null)
      case Some(value) => lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getBoolean(columnIndex: Int): F[Boolean] =
    checkClosed() *> rowDecode[Boolean](
      columnIndex,
      {
        case "true" | "1"  => Right(true)
        case "false" | "0" => Right(false)
        case unknown       => Left(s"Unknown boolean value: $unknown")
      }
    ).flatMap {
      case None => lastColumnReadNullable.set(true) *> ev.pure(false)
      case Some(value) => lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getByte(columnIndex: Int): F[Byte] =
    checkClosed() *> rowDecode[Byte](
      columnIndex,
      str => {
        if str.length == 1 && !str.forall(_.isDigit) then Right(str.getBytes().head)
        else Right(str.toByte)
      }
    ).flatMap {
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(0)
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getShort(columnIndex: Int): F[Short] =
    checkClosed() *> rowDecode[Short](columnIndex, str => Try(str.toShort).toEither.left.map(_.getMessage)).flatMap {
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(0)
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getInt(columnIndex: Int): F[Int] =
    checkClosed() *> rowDecode[Int](columnIndex, str => Try(str.toInt).toEither.left.map(_.getMessage)).flatMap {
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(0)
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getLong(columnIndex: Int): F[Long] =
    checkClosed() *> rowDecode[Long](
      columnIndex,
      str => Try(str.toLong).toEither.left.map(_.getMessage)
    ).flatMap {
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(0L)
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getFloat(columnIndex: Int): F[Float] =
    checkClosed() *> rowDecode[Float](
      columnIndex,
      str => Try(str.toFloat).toEither.left.map(_.getMessage)
    ).flatMap {
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(0f)
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getDouble(columnIndex: Int): F[Double] =
    checkClosed() *> rowDecode[Double](
      columnIndex,
      str => Try(str.toDouble).toEither.left.map(_.getMessage)
    ).flatMap {
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(0.0)
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
    }

  override def getBytes(columnIndex: Int): F[Array[Byte]] =
    checkClosed() *> rowDecode[Array[Byte]](
      columnIndex,
      str => Right(str.getBytes("UTF-8"))
    ).flatMap {
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(null)
    }

  override def getDate(columnIndex: Int): F[LocalDate] =
    checkClosed() *> rowDecode[LocalDate](
      columnIndex,
      str => Try(LocalDate.parse(str, localDateFormatter)).toEither.left.map(_.getMessage)
    ).flatMap {
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(null)
    }

  override def getTime(columnIndex: Int): F[LocalTime] =
    checkClosed() *> rowDecode[LocalTime](
      columnIndex,
      str => Try(LocalTime.parse(str, timeFormatter(6))).toEither.left.map(_.getMessage)
    ).flatMap {
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(null)
    }

  override def getTimestamp(columnIndex: Int): F[LocalDateTime] =
    checkClosed() *>
      rowDecode[LocalDateTime](
        columnIndex,
        str => {
          val parser = ResultSetImpl.temporalDecode(localDateTimeFormatter(6), LocalDateTime.parse)
          Try(parser(str)).toEither.left.map(_.getMessage)
        }
      ).flatMap {
        case Some(value) =>
          lastColumnReadNullable.set(false) *> ev.pure(value)
        case None =>
          lastColumnReadNullable.set(true) *> ev.pure(null)
      }

  override def getString(columnLabel: String): F[String] =
    for
      index <- findByName(columnLabel)
      value <- getString(index)
    yield value

  override def getBoolean(columnLabel: String): F[Boolean] =
    for 
      index <- findByName(columnLabel)
      value <- getBoolean(index)
    yield value

  override def getByte(columnLabel: String): F[Byte] =
    for
      index <- findByName(columnLabel)
      value <- getByte(index)
    yield value

  override def getShort(columnLabel: String): F[Short] =
    for 
      index <- findByName(columnLabel)
      value <- getShort(index)
    yield value

  override def getInt(columnLabel: String): F[Int] =
    for
      index <- findByName(columnLabel)
      value <- getInt(index)
    yield value

  override def getLong(columnLabel: String): F[Long] =
    for 
      index <- findByName(columnLabel)
      value <- getLong(index)
    yield value

  override def getFloat(columnLabel: String): F[Float] =
    for
      index <- findByName(columnLabel)
      value <- getFloat(index)
    yield value

  override def getDouble(columnLabel: String): F[Double] =
    for
      index <- findByName(columnLabel)
      value <- getDouble(index)
    yield value

  override def getBytes(columnLabel: String): F[Array[Byte]] =
    for
      index <- findByName(columnLabel)
      value <- getBytes(index)
    yield value

  override def getDate(columnLabel: String): F[LocalDate] =
    for
      index <- findByName(columnLabel)
      value <- getDate(index)
    yield value

  override def getTime(columnLabel: String): F[LocalTime] =
    for
      index <- findByName(columnLabel)
      value <- getTime(index)
    yield value

  override def getTimestamp(columnLabel: String): F[LocalDateTime] =
    for
      index <- findByName(columnLabel)
      value <- getTimestamp(index)
    yield value

  override def getMetaData(): F[ResultSetMetaData] =
    checkClosed().map { _ =>
      ResultSetMetaDataImpl(columns, serverVariables, version)
    }

  override def getBigDecimal(columnIndex: Int): F[BigDecimal] =
    checkClosed() *> rowDecode[BigDecimal](
      columnIndex,
      str => Try(BigDecimal(str)).toEither.left.map(_.getMessage)
    ).flatMap {
      case Some(value) =>
        lastColumnReadNullable.set(false) *> ev.pure(value)
      case None =>
        lastColumnReadNullable.set(true) *> ev.pure(null)
    }

  override def getBigDecimal(columnLabel: String): F[BigDecimal] =
    for
      index <- findByName(columnLabel)
      value <- getBigDecimal(index)
    yield value

  override def isBeforeFirst(): F[Boolean] =
    currentCursor.get.map { cursor =>
      cursor <= 0 && records.nonEmpty
    }

  override def isAfterLast(): F[Boolean] =
    currentCursor.get.map { cursor =>
      cursor > records.length && records.nonEmpty
    }

  override def isFirst(): F[Boolean] =
    currentCursor.get.map(_ > 0)

  override def isLast(): F[Boolean] =
    currentCursor.get.map(_ == records.length)

  override def beforeFirst(): F[Unit] =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      ev.raiseError(new SQLException(
      "Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.",
        sql = statement
      ))
    else currentCursor.set(0)

  override def afterLast(): F[Unit] =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      ev.raiseError(new SQLException(
        "Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.",
        sql = statement
      ))
    else currentCursor.set(records.length + 1)

  override def first(): F[Boolean] =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      ev.raiseError(new SQLException(
        "Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.",
        sql = statement
      ))
    else
      currentCursor.set(1) *>
        currentRow.set(records.headOption) *>
        currentRow.get.map { row =>
          row.isDefined && records.nonEmpty
        }

  override def last(): F[Boolean] =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      ev.raiseError(new SQLException(
        "Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.",
        sql = statement
      ))
    else
      currentCursor.set(records.length) *> 
        currentRow.set(records.lastOption) *> 
        currentRow.get.map { row =>
          row.isDefined && records.nonEmpty
        }

  override def getRow(): F[Int] =
    currentCursor.get.map { cursor =>
      cursor > records.length match
        case true  => 0
        case false => cursor
    }

  override def absolute(row: Int): F[Boolean] =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      ev.raiseError(new SQLException(
        "Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.",
        sql = statement
      ))
    else if row > 0 then
      currentCursor.set(row) *>
        currentRow.set(records.lift(row - 1)) *>
        ev.pure(row >= 1 && row <= records.length)
    else if row < 0 then
      val position = records.length + row + 1
      currentCursor.set(position) *>
        currentRow.set(records.lift(records.length + row)) *>
        ev.pure(position >= 1 && position <= records.length)
    else
      currentCursor.set(0) *> 
        currentRow.set(None) *> 
        ev.pure(false)

  override def relative(rows: Int): F[Boolean] =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      ev.raiseError(new SQLException(
        "Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.",
        sql = statement
      ))
    else
      currentCursor.get.flatMap { cursor =>
        val position = cursor + rows
        if position >= 1 && position <= records.length then
          currentCursor.set(position) *> 
            currentRow.set(records.lift(position - 1)) *> 
            ev.pure(true)
        else
          currentCursor.set(0) *>
            currentRow.set(records.headOption) *>
            ev.pure(false)
      }

  override def previous(): F[Boolean] =
    if resultSetType == ResultSet.TYPE_FORWARD_ONLY then
      ev.raiseError(new SQLException(
        "Operation not allowed for a result set of type ResultSet.TYPE_FORWARD_ONLY.",
        sql = statement
      ))
    else
      currentCursor.get.flatMap { cursor =>
        if cursor > 0 then
          currentCursor.set(cursor - 1) *> 
            currentRow.set(records.lift(cursor - 1)) *>
            currentRow.get.map { row =>
              row.isDefined
            }
        else
          currentCursor.set(0) *> 
            currentRow.set(None) *>
            ev.pure(false)
      }

  override def getType(): F[Int] =
    checkClosed() *> ev.pure(resultSetType)

  override def getConcurrency(): F[Int] =
    checkClosed() *> ev.pure(resultSetConcurrency)

  /**
   * Does the result set contain rows, or is it the result of a DDL or DML statement?
   *
   * @return true if result set contains rows
   */
  def hasRows(): F[Boolean] =
    checkClosed() *> 
      ev.pure(records.length > 0)

  /**
   * Returns the number of rows in this <code>ResultSet</code> object.
   *
   * @return
   *   the number of rows
   */
  def rowLength(): F[Int] =
    checkClosed() *> 
      ev.pure(records.length)

  private def rowDecode[T](index: Int, decode: String => Either[String, T]): F[Option[T]] =
    for
      row <- currentRow.get
      decoded <- row.flatMap(_.values(index - 1)) match
        case None => ev.pure(None)
        case Some(value) => decode(value) match
          case Left(error) => ev.raiseError(new SQLException(error, sql = statement))
          case Right(decodedValue) => ev.pure(Some(decodedValue))
    yield decoded

  private def findByName(columnLabel: String): F[Int] =
    val column = columns.zipWithIndex
      .find { (column: ColumnDefinitionPacket, _) =>
        column.name.equalsIgnoreCase(columnLabel) || column.fullName.equalsIgnoreCase(columnLabel)
      }
    column match
      case None =>
        ev.raiseError(new SQLException(
          s"Column name '$columnLabel' does not exist in the ResultSet.",
          sql = statement
        ))
      case Some((_, index)) => ev.pure(index + 1)

  private def checkClosed(): F[Unit] =
    isClosed.get.flatMap { closed =>
      if closed then
        ev.raiseError(new SQLException(ResultSetImpl.CLOSED_MESSAGE, sql = statement))
      else
        ().pure[F]
    }

private[ldbc] object ResultSetImpl:

  private[ldbc] final val CLOSED_MESSAGE = "Operation not allowed after ResultSet closed"

  private[ldbc] def temporalDecode[A <: TemporalAccessor](
    formatter: DateTimeFormatter,
    parse:     (String, DateTimeFormatter) => A
  ): String => A = str => parse(str, formatter)

  def apply[F[_]: MonadThrow](
    protocol:        Protocol[F],
    columns:         Vector[ColumnDefinitionPacket],
    records:         Vector[ResultSetRowPacket],
    serverVariables: Map[String, String],
    version:         Version,
    isClosed:            Ref[F, Boolean],
    lastColumnReadNullable: Ref[F, Boolean],
    currentCursor:       Ref[F, Int],
    currentRow:          Ref[F, Option[ResultSetRowPacket]],
    fetchSize: Ref[F, Long],
    useCursorFetch: Ref[F, Boolean],
    useServerPrepStmts: Ref[F, Boolean],
  ): ResultSetImpl[F] =
    ResultSetImpl[F](
      protocol,
      columns,
      records,
      serverVariables,
      version,
      isClosed,
      lastColumnReadNullable,
      currentCursor,
      currentRow,
      fetchSize,
      useCursorFetch,
      useServerPrepStmts,
      ResultSet.TYPE_FORWARD_ONLY
    )

  def empty[F[_]: MonadThrow](
    protocol:        Protocol[F],
    serverVariables: Map[String, String],
    version:         Version,
    isClosed:            Ref[F, Boolean],
    lastColumnReadNullable: Ref[F, Boolean],
    currentCursor:       Ref[F, Int],
    currentRow:          Ref[F, Option[ResultSetRowPacket]],
    fetchSize: Ref[F, Long],
    useCursorFetch: Ref[F, Boolean],
    useServerPrepStmts: Ref[F, Boolean],
  ): ResultSetImpl[F] =
    this.apply[F](
      protocol,
      Vector.empty,
      Vector.empty,
      serverVariables,
      version,
      isClosed,
      lastColumnReadNullable,
      currentCursor,
      currentRow,
      fetchSize,
      useCursorFetch,
      useServerPrepStmts,
    )
