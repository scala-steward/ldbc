/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector.net.protocol

import scala.collection.immutable.{ ListMap, SortedMap }

import cats.*
import cats.syntax.all.*

import cats.effect.*

import org.typelevel.otel4s.trace.{ Span, Tracer }
import org.typelevel.otel4s.Attribute

import ldbc.sql.{ PreparedStatement, ResultSet, Statement }

import ldbc.connector.data.*
import ldbc.connector.exception.SQLException
import ldbc.connector.net.packet.request.*
import ldbc.connector.net.packet.response.*
import ldbc.connector.net.Protocol
import ldbc.connector.util.OpenTelemetryAttributes.*
import ldbc.connector.ResultSetImpl

private[ldbc] case class StatementImpl[F[_]: Exchange: Tracer: Sync](
  protocol:             Protocol[F],
  serverVariables:      Map[String, String],
  batchedArgs:          Ref[F, Vector[String]],
  connectionClosed:     Ref[F, Boolean],
  statementClosed:      Ref[F, Boolean],
  resultSetClosed:      Ref[F, Boolean],
  currentResultSet:     Ref[F, Option[ResultSet[F]]],
  updateCount:          Ref[F, Long],
  moreResults:          Ref[F, Boolean],
  autoGeneratedKeys:    Ref[F, Int],
  lastInsertId:         Ref[F, Long],
  fetchSize:            Ref[F, Int],
  useCursorFetch:       Boolean,
  useServerPrepStmts:   Boolean,
  resultSetType:        Int = ResultSet.TYPE_FORWARD_ONLY,
  resultSetConcurrency: Int = ResultSet.CONCUR_READ_ONLY
)(using F: MonadThrow[F])
  extends StatementImpl.ShareStatement[F]:

  private val baseAttributes = List(
    dbSystemName,
    serverAddress(protocol.hostInfo.host),
    serverPort(protocol.hostInfo.port),
    dbMysqlVersion(protocol.initialPacket.serverVersion.toString),
    dbMysqlThreadId(protocol.initialPacket.threadId),
    statementType("Statement")
  ) ++ protocol.hostInfo.database.map(dbNamespace).toList

  private def simpleQueryRun(sql: String): F[ResultSet[F]] =
    val operation = extractOperationName(sql)
    val table     = extractTableName(sql)
    val spanName  = createSpanName(operation, table)

    exchange[F, ResultSet[F]](spanName) { (span: Span[F]) =>
      val queryAttributes = baseAttributes ++ List(
        dbOperationName(operation),
        dbQueryText(sql),
        dbQuerySummary(sanitizeSql(sql))
      ) ++ table.map(dbCollectionName).toList

      span.addAttributes(queryAttributes*) *>
        protocol.resetSequenceId *>
        protocol.send(ComQueryPacket(sql, protocol.initialPacket.capabilityFlags, ListMap.empty)) *>
        protocol.receive(ColumnsNumberPacket.decoder(protocol.initialPacket.capabilityFlags)).flatMap {
          case _: OKPacket =>
            for
              resultSet <- F.pure(
                             ResultSetImpl
                               .empty(
                                 protocol,
                                 serverVariables,
                                 protocol.initialPacket.serverVersion,
                                 resultSetClosed,
                                 fetchSize,
                                 useCursorFetch,
                                 useServerPrepStmts
                               )
                           )
              _ <- currentResultSet.set(Some(resultSet))
            yield resultSet
          case error: ERRPacket            => F.raiseError(error.toException(Some(sql), None))
          case result: ColumnsNumberPacket =>
            for
              columnDefinitions <-
                protocol.repeatProcess(
                  result.size,
                  ColumnDefinitionPacket.decoder(protocol.initialPacket.capabilityFlags)
                )
              resultSetRow <-
                protocol.readUntilEOF[ResultSetRowPacket](
                  ResultSetRowPacket.decoder(protocol.initialPacket.capabilityFlags, columnDefinitions.length)
                )
              resultSet = ResultSetImpl(
                            protocol,
                            columnDefinitions,
                            resultSetRow,
                            serverVariables,
                            protocol.initialPacket.serverVersion,
                            resultSetClosed,
                            fetchSize,
                            useCursorFetch,
                            useServerPrepStmts,
                            resultSetType,
                            resultSetConcurrency,
                            Some(sql)
                          )
              _ <- currentResultSet.set(Some(resultSet))
            yield resultSet
        }
    }

  private def buildServerPreparedStatement(sql: String): F[PreparedStatement[F]] =
    for
      result <- protocol.resetSequenceId *> protocol.send(ComStmtPreparePacket(sql)) *>
                  protocol.receive(ComStmtPrepareOkPacket.decoder(protocol.initialPacket.capabilityFlags)).flatMap {
                    case error: ERRPacket           => F.raiseError(error.toException(Some(sql), None))
                    case ok: ComStmtPrepareOkPacket => F.pure(ok)
                  }
      _ <- protocol.repeatProcess(
             result.numParams,
             ColumnDefinitionPacket.decoder(protocol.initialPacket.capabilityFlags)
           )
      _ <- protocol.repeatProcess(
             result.numColumns,
             ColumnDefinitionPacket.decoder(protocol.initialPacket.capabilityFlags)
           )
      params            <- Ref[F].of(SortedMap.empty[Int, Parameter])
      batchedArgs       <- Ref[F].of(Vector.empty[String])
      statementClosed   <- Ref[F].of[Boolean](false)
      resultSetClosed   <- Ref[F].of[Boolean](false)
      currentResultSet  <- Ref[F].of[Option[ResultSet[F]]](None)
      updateCount       <- Ref[F].of(-1L)
      moreResults       <- Ref[F].of(false)
      autoGeneratedKeys <- Ref[F].of(Statement.NO_GENERATED_KEYS)
      lastInsertId      <- Ref[F].of(0L)
    yield ServerPreparedStatement[F](
      protocol,
      serverVariables,
      result.statementId,
      sql,
      params,
      batchedArgs,
      connectionClosed,
      statementClosed,
      resultSetClosed,
      currentResultSet,
      updateCount,
      moreResults,
      autoGeneratedKeys,
      lastInsertId,
      fetchSize,
      useCursorFetch,
      useServerPrepStmts,
      resultSetType,
      resultSetConcurrency
    )

  private def buildClientPreparedStatement(sql: String): F[PreparedStatement[F]] =
    for
      params            <- Ref[F].of(SortedMap.empty[Int, Parameter])
      batchedArgs       <- Ref[F].of(Vector.empty[String])
      statementClosed   <- Ref[F].of[Boolean](false)
      resultSetClosed   <- Ref[F].of[Boolean](false)
      currentResultSet  <- Ref[F].of[Option[ResultSet[F]]](None)
      updateCount       <- Ref[F].of(-1L)
      moreResults       <- Ref[F].of(false)
      autoGeneratedKeys <- Ref[F].of(Statement.NO_GENERATED_KEYS)
      lastInsertId      <- Ref[F].of(0L)
    yield ClientPreparedStatement[F](
      protocol,
      serverVariables,
      sql,
      params,
      batchedArgs,
      connectionClosed,
      statementClosed,
      resultSetClosed,
      currentResultSet,
      updateCount,
      moreResults,
      autoGeneratedKeys,
      lastInsertId,
      fetchSize,
      useCursorFetch,
      useServerPrepStmts,
      resultSetType,
      resultSetConcurrency
    )

  private def preparedQueryRun(sql: String): F[ResultSet[F]] =
    for
      preparedStatement <- F.ifM[PreparedStatement[F]](F.pure(useServerPrepStmts))(
                             buildServerPreparedStatement(sql),
                             buildClientPreparedStatement(sql)
                           )
      resultSet <- preparedStatement.executeQuery()
    yield resultSet

  override def executeQuery(sql: String): F[ResultSet[F]] =
    checkClosed() *> checkNullOrEmptyQuery(sql) *>
      F.ifM(useServerFetch())(
        preparedQueryRun(sql),
        simpleQueryRun(sql)
      )

  override def executeUpdate(sql: String): F[Int] =
    executeLargeUpdate(sql).map(_.toInt)

  override def executeLargeUpdate(sql: String): F[Long] =
    checkClosed() *> checkNullOrEmptyQuery(sql) *> {
      val operation = extractOperationName(sql)
      val table     = extractTableName(sql)
      val spanName  = createSpanName(operation, table)

      exchange[F, Long](spanName) { (span: Span[F]) =>
        val queryAttributes = baseAttributes ++ List(
          dbOperationName(operation),
          dbQueryText(sql),
          dbQuerySummary(sanitizeSql(sql))
        ) ++ table.map(dbCollectionName).toList

        span.addAttributes(queryAttributes*) *> protocol.resetSequenceId *> (
          protocol.send(ComQueryPacket(sql, protocol.initialPacket.capabilityFlags, ListMap.empty)) *>
            protocol.receive(GenericResponsePackets.decoder(protocol.initialPacket.capabilityFlags)).flatMap {
              case result: OKPacket =>
                lastInsertId.set(result.lastInsertId) *> updateCount.updateAndGet(_ => result.affectedRows)
              case error: ERRPacket => F.raiseError(error.toException(Some(sql), None))
              case _: EOFPacket     => F.raiseError(new SQLException("Unexpected EOF packet"))
            }
        )
      }
    }

  override def close(): F[Unit] = statementClosed.set(true) *> resultSetClosed.set(true)

  override def execute(sql: String): F[Boolean] =
    checkClosed() *> checkNullOrEmptyQuery(sql) *> (
      if sql.toUpperCase.startsWith("SELECT") then
        executeQuery(sql).flatMap {
          case resultSet: ResultSetImpl[F] => resultSet.hasRows()
          case _                           => F.pure(false)
        }
      else executeUpdate(sql).map(_ => false)
    )

  override def addBatch(sql: String): F[Unit] = batchedArgs.update(_ :+ sql)

  override def clearBatch(): F[Unit] = batchedArgs.set(Vector.empty)

  override def executeLargeBatch(): F[Array[Long]] =
    checkClosed() *> protocol.resetSequenceId *>
      protocol.comSetOption(EnumMySQLSetOption.MYSQL_OPTION_MULTI_STATEMENTS_ON) *>
      exchange[F, Array[Long]]("BATCH") { (span: Span[F]) =>
        batchedArgs.get.flatMap { args =>
          val batchAttributes = baseAttributes ++ List(
            dbOperationName("BATCH"),
            batchSize(args.length.toLong)
          )

          span.addAttributes(batchAttributes*) *> (
            if args.isEmpty then F.pure(Array.empty)
            else
              protocol.resetSequenceId *>
                protocol.send(
                  ComQueryPacket(args.mkString(";"), protocol.initialPacket.capabilityFlags, ListMap.empty)
                ) *>
                args
                  .foldLeft(F.pure(Vector.empty[Long])) { ($acc, _) =>
                    for
                      acc    <- $acc
                      result <-
                        protocol
                          .receive(GenericResponsePackets.decoder(protocol.initialPacket.capabilityFlags))
                          .flatMap {
                            case result: OKPacket =>
                              lastInsertId.set(result.lastInsertId) *> F.pure(acc :+ result.affectedRows)
                            case error: ERRPacket =>
                              F.raiseError(error.toException("Failed to execute batch", acc))
                            case _: EOFPacket => F.raiseError(new SQLException("Unexpected EOF packet"))
                          }
                    yield result
                  }
                  .map(_.toArray)
          )
        }
      } <* protocol.resetSequenceId <* protocol.comSetOption(
        EnumMySQLSetOption.MYSQL_OPTION_MULTI_STATEMENTS_OFF
      ) <* clearBatch()

  override def getGeneratedKeys(): F[ResultSet[F]] =
    autoGeneratedKeys.get.flatMap {
      case Statement.RETURN_GENERATED_KEYS =>
        for
          lastInsertId <- lastInsertId.get
          record    = ResultSetRowPacket(Array(Some(lastInsertId.toString)))
          resultSet = ResultSetImpl(
                        protocol,
                        Vector(new ColumnDefinitionPacket:
                          override def table: String = ""

                          override def name: String = "GENERATED_KEYS"

                          override def columnType: ColumnDataType = ColumnDataType.MYSQL_TYPE_LONGLONG

                          override def flags: Seq[ColumnDefinitionFlags] = Seq.empty),
                        Vector(record),
                        serverVariables,
                        protocol.initialPacket.serverVersion,
                        resultSetClosed,
                        fetchSize,
                        useCursorFetch,
                        useServerPrepStmts
                      )
          _ <- currentResultSet.set(Some(resultSet))
        yield resultSet
      case Statement.NO_GENERATED_KEYS =>
        F.raiseError(
          new SQLException(
            "Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement()."
          )
        )
    }

object StatementImpl:

  private[ldbc] trait ShareStatement[F[_]](using F: MonadThrow[F]) extends Statement[F]:

    def statementClosed:   Ref[F, Boolean]
    def connectionClosed:  Ref[F, Boolean]
    def currentResultSet:  Ref[F, Option[ResultSet[F]]]
    def updateCount:       Ref[F, Long]
    def moreResults:       Ref[F, Boolean]
    def autoGeneratedKeys: Ref[F, Int]
    def lastInsertId:      Ref[F, Long]

    def fetchSize:      Ref[F, Int]
    def useCursorFetch: Boolean
    def resultSetType:  Int

    override def getResultSet():        F[Option[ResultSet[F]]] = checkClosed() *> currentResultSet.get
    override def getUpdateCount():      F[Int]                  = checkClosed() *> updateCount.get.map(_.toInt)
    override def getLargeUpdateCount(): F[Long]                 = checkClosed() *> updateCount.get
    override def getMoreResults():      F[Boolean]              = checkClosed() *> moreResults.get

    override def executeUpdate(sql: String, autoGeneratedKeys: Int): F[Int] =
      this.autoGeneratedKeys.set(autoGeneratedKeys) *> executeUpdate(sql)

    override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): F[Long] =
      this.autoGeneratedKeys.set(autoGeneratedKeys) *> executeLargeUpdate(sql)

    override def execute(sql: String, autoGeneratedKeys: Int): F[Boolean] =
      this.autoGeneratedKeys.set(autoGeneratedKeys) *> execute(sql)

    override def isClosed(): F[Boolean] =
      for
        connClosed <- connectionClosed.get
        stmtClosed <- statementClosed.get
      yield connClosed || stmtClosed

    override def executeBatch(): F[Array[Int]] = executeLargeBatch().map(_.map(_.toInt))

    override def setFetchSize(rows: Int): F[Unit] = fetchSize.set(rows)

    override def getFetchSize(): F[Int] = fetchSize.get

    protected def checkClosed(): F[Unit] =
      isClosed().ifM(
        close() *> F.raiseError(new SQLException("No operations allowed after statement closed.")),
        F.unit
      )

    protected def checkNullOrEmptyQuery(sql: String): F[Unit] =
      if sql.isEmpty then F.raiseError(new SQLException("Can not issue empty query."))
      else if sql == null then F.raiseError(new SQLException("Can not issue NULL query."))
      else F.unit

    protected def useServerFetch(): F[Boolean] =
      fetchSize.get.map { fetchSize =>
        useCursorFetch && fetchSize > 0 && resultSetType == ResultSet.TYPE_FORWARD_ONLY
      }
