/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector.pool

import cats.effect.*
import cats.syntax.all.*

import ldbc.sql.*
import ldbc.connector.Connection

/**
 * A high-performance proxy for pooled connections that tracks statements
 * and ensures proper cleanup when connections are returned to the pool.
 * 
 * This implementation uses FastList for statement tracking to minimize
 * allocations and maximize performance, following HikariCP's approach.
 * 
 * @param pooled the pooled connection being wrapped
 * @param releaseCallback callback to invoke when the connection is released
 * @param closeAllStatements whether to close all statements when the connection is released
 * @tparam F the effect type
 */
private[pool] class ProxyConnection[F[_]: Temporal](
  val pooled:           PooledConnection[F],
  releaseCallback:      Connection[F] => F[Unit],
  closeAllStatements:   Boolean = true
) extends Connection[F]:

  private val openStatements = new FastList[Statement[F]]()
  private val delegate: Connection[F] = pooled.connection

  // Override close to return to pool instead of closing
  override def close(): F[Unit] = 
    val cleanup = if closeAllStatements then closeTrackedStatements() else Temporal[F].unit
    cleanup >> releaseCallback(this)

  // Track statement creation
  override def createStatement(): F[Statement[F]] = 
    delegate.createStatement().map { stmt =>
      openStatements.add(stmt)
      stmt
    }

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int): F[Statement[F]] =
    delegate.createStatement(resultSetType, resultSetConcurrency).map { stmt =>
      openStatements.add(stmt)
      stmt
    }

  override def prepareStatement(sql: String): F[PreparedStatement[F]] = 
    delegate.prepareStatement(sql).map { stmt =>
      openStatements.add(stmt)
      stmt
    }

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): F[PreparedStatement[F]] =
    delegate.prepareStatement(sql, resultSetType, resultSetConcurrency).map { stmt =>
      openStatements.add(stmt)
      stmt
    }

  override def prepareStatement(sql: String, autoGeneratedKeys: Int): F[PreparedStatement[F]] =
    delegate.prepareStatement(sql, autoGeneratedKeys).map { stmt =>
      openStatements.add(stmt)
      stmt
    }

  override def prepareCall(sql: String): F[CallableStatement[F]] = 
    delegate.prepareCall(sql).map { stmt =>
      openStatements.add(stmt)
      stmt
    }

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): F[CallableStatement[F]] =
    delegate.prepareCall(sql, resultSetType, resultSetConcurrency).map { stmt =>
      openStatements.add(stmt)
      stmt
    }

  /**
   * Close all tracked statements.
   * This is called when the connection is returned to the pool to ensure
   * no statements leak.
   */
  private def closeTrackedStatements(): F[Unit] = {
    val stmts = List.newBuilder[Statement[F]]
    openStatements.foreach(stmts += _)
    val allStatements = stmts.result()
    
    // Clear the list first to avoid concurrent modification
    openStatements.clear()
    
    // Close all statements, ignoring errors
    allStatements.traverse_(_.close().attempt.void)
  }

  // Delegate all other methods without modification
  override def nativeSQL(sql: String): F[String] = delegate.nativeSQL(sql)
  override def getAutoCommit(): F[Boolean] = delegate.getAutoCommit()
  override def setAutoCommit(autoCommit: Boolean): F[Unit] = delegate.setAutoCommit(autoCommit)
  override def commit(): F[Unit] = delegate.commit()
  override def rollback(): F[Unit] = delegate.rollback()
  override def getTransactionIsolation(): F[Int] = delegate.getTransactionIsolation()
  override def setTransactionIsolation(level: Int): F[Unit] = delegate.setTransactionIsolation(level)
  override def isReadOnly: F[Boolean] = delegate.isReadOnly
  override def setReadOnly(readOnly: Boolean): F[Unit] = delegate.setReadOnly(readOnly)
  override def getCatalog(): F[String] = delegate.getCatalog()
  override def setCatalog(catalog: String): F[Unit] = delegate.setCatalog(catalog)
  override def isClosed(): F[Boolean] = delegate.isClosed()
  override def isValid(timeout: Int): F[Boolean] = delegate.isValid(timeout)
  override def getMetaData(): F[DatabaseMetaData[F]] = delegate.getMetaData()
  override def setSavepoint(): F[Savepoint] = delegate.setSavepoint()
  override def setSavepoint(name: String): F[Savepoint] = delegate.setSavepoint(name)
  override def releaseSavepoint(savepoint: Savepoint): F[Unit] = delegate.releaseSavepoint(savepoint)
  override def rollback(savepoint: Savepoint): F[Unit] = delegate.rollback(savepoint)
  override def setSchema(schema: String): F[Unit] = delegate.setSchema(schema)
  override def getSchema(): F[String] = delegate.getSchema()