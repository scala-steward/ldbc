/**
 * Copyright (c) 2023-2025 by Takahiko Tominaga
 * This software is licensed under the MIT License (MIT).
 * For more information see LICENSE or https://opensource.org/licenses/MIT
 */

package ldbc.connector.pool

import scala.concurrent.duration.*

import cats.effect.*
import cats.effect.std.Console

import org.typelevel.otel4s.trace.Tracer

import ldbc.sql.*
import ldbc.connector.{ Connection as LdbcConnection, * }

class ProxyConnectionTest extends FTestPlatform:

  given Tracer[IO] = Tracer.noop[IO]

  def connection: Resource[IO, LdbcConnection[IO]] = LdbcConnection[IO](
    host     = "127.0.0.1",
    port     = 13306,
    user     = "ldbc",
    password = Some("password"),
    database = Some("connector_test"),
    ssl      = SSL.Trusted
  )

  // Helper to create a pooled connection
  def createPooledConnection(id: String, conn: LdbcConnection[IO]): IO[PooledConnection[IO]] =
    for
      currentTime      <- IO.realTime.map(_.toMillis)
      stateRef         <- Ref[IO].of[ConnectionState](ConnectionState.Idle)
      lastUsedRef      <- Ref[IO].of(currentTime)
      useCountRef      <- Ref[IO].of(0L)
      lastValidatedRef <- Ref[IO].of(currentTime)
      leakDetectionRef <- Ref[IO].of(Option.empty[Fiber[IO, Throwable, Unit]])
      bagStateRef      <- Ref[IO].of(BagEntry.STATE_NOT_IN_USE)
    yield PooledConnection[IO](
      id              = id,
      connection      = conn,
      finalizer       = IO.unit,
      state           = stateRef,
      createdAt       = currentTime,
      lastUsedAt      = lastUsedRef,
      useCount        = useCountRef,
      lastValidatedAt = lastValidatedRef,
      leakDetection   = leakDetectionRef,
      bagState        = bagStateRef
    )

  test("ProxyConnection should track created statements") {
    connection.use { conn =>
      for
        pooledConn      <- createPooledConnection("test-1", conn)
        callbackInvoked <- Ref[IO].of(false)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => callbackInvoked.set(true),
                  closeAllStatements = true
                )

        // Create multiple statements
        stmt1 <- proxy.createStatement()
        stmt2 <- proxy.createStatement()
        stmt3 <- proxy.createStatement()

        // Close the proxy connection
        _ <- proxy.close()

        wasInvoked <- callbackInvoked.get
      yield assert(wasInvoked, "Release callback should have been invoked")
    }
  }

  test("ProxyConnection should close all tracked statements on close when closeAllStatements is true") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)
        closedStmts <- Ref[IO].of(List.empty[String])

        // Mock statement that tracks close calls
        mockStmt = new Statement[IO] {
          override def close(): IO[Unit] = closedStmts.update(_ :+ "stmt")
          override def execute(sql: String): IO[Boolean] = IO.pure(false)
          override def executeQuery(sql: String): IO[ResultSet[IO]] = IO.raiseError(new UnsupportedOperationException)
          override def executeUpdate(sql: String): IO[Int] = IO.pure(0)
          override def getResultSet(): IO[Option[ResultSet[IO]]] = IO.pure(None)
          override def getUpdateCount(): IO[Int] = IO.pure(0)
          override def getMoreResults(): IO[Boolean] = IO.pure(false)
          override def setFetchSize(rows: Int): IO[Unit] = IO.unit
          override def getFetchSize(): IO[Int] = IO.pure(0)
          override def addBatch(sql: String): IO[Unit] = IO.unit
          override def clearBatch(): IO[Unit] = IO.unit
          override def executeBatch(): IO[Array[Int]] = IO.pure(Array.empty)
          override def getGeneratedKeys(): IO[ResultSet[IO]] = IO.raiseError(new UnsupportedOperationException)
          override def executeUpdate(sql: String, autoGeneratedKeys: Int): IO[Int] = IO.pure(0)
          override def execute(sql: String, autoGeneratedKeys: Int): IO[Boolean] = IO.pure(false)
          override def isClosed(): IO[Boolean] = IO.pure(false)
          override def getLargeUpdateCount(): IO[Long] = IO.pure(0L)
          override def executeLargeUpdate(sql: String): IO[Long] = IO.pure(0L)
          override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): IO[Long] = IO.pure(0L)
          override def executeLargeBatch(): IO[Array[Long]] = IO.pure(Array.empty)
        }

        // Create a custom connection that returns our mock statements
        customConn = new LdbcConnection[IO] {
          // Delegate most methods to the real connection
          override def createStatement(): IO[Statement[IO]] = IO.pure(mockStmt)
          override def close(): IO[Unit] = conn.close()
          override def isClosed(): IO[Boolean] = conn.isClosed()
          override def prepareStatement(sql: String): IO[PreparedStatement[IO]] = conn.prepareStatement(sql)
          override def prepareCall(sql: String): IO[CallableStatement[IO]] = conn.prepareCall(sql)
          override def nativeSQL(sql: String): IO[String] = conn.nativeSQL(sql)
          override def setAutoCommit(autoCommit: Boolean): IO[Unit] = conn.setAutoCommit(autoCommit)
          override def getAutoCommit(): IO[Boolean] = conn.getAutoCommit()
          override def commit(): IO[Unit] = conn.commit()
          override def rollback(): IO[Unit] = conn.rollback()
          override def getMetaData(): IO[DatabaseMetaData[IO]] = conn.getMetaData()
          override def setReadOnly(readOnly: Boolean): IO[Unit] = conn.setReadOnly(readOnly)
          override def isReadOnly: IO[Boolean] = conn.isReadOnly
          override def setCatalog(catalog: String): IO[Unit] = conn.setCatalog(catalog)
          override def getCatalog(): IO[String] = conn.getCatalog()
          override def setTransactionIsolation(level: Int): IO[Unit] = conn.setTransactionIsolation(level)
          override def getTransactionIsolation(): IO[Int] = conn.getTransactionIsolation()
          override def createStatement(resultSetType: Int, resultSetConcurrency: Int): IO[Statement[IO]] = IO.pure(mockStmt)
          override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, resultSetType, resultSetConcurrency)
          override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): IO[CallableStatement[IO]] = conn.prepareCall(sql, resultSetType, resultSetConcurrency)
          override def setSavepoint(): IO[Savepoint] = conn.setSavepoint()
          override def setSavepoint(name: String): IO[Savepoint] = conn.setSavepoint(name)
          override def rollback(savepoint: Savepoint): IO[Unit] = conn.rollback(savepoint)
          override def releaseSavepoint(savepoint: Savepoint): IO[Unit] = conn.releaseSavepoint(savepoint)
          override def prepareStatement(sql: String, autoGeneratedKeys: Int): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, autoGeneratedKeys)
          override def setSchema(schema: String): IO[Unit] = conn.setSchema(schema)
          override def getSchema(): IO[String] = conn.getSchema()
          override def isValid(timeout: Int): IO[Boolean] = conn.isValid(timeout)
        }

        customPooledConn <- createPooledConnection("test-2", customConn)

        proxy = new ProxyConnection[IO](
                  customPooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create statements through proxy
        _ <- proxy.createStatement()
        _ <- proxy.createStatement()
        _ <- proxy.createStatement()

        // Close should close all statements
        _ <- proxy.close()

        closed <- closedStmts.get
      yield assertEquals(closed.length, 3, "All 3 statements should have been closed")
    }
  }

  test("ProxyConnection should not close statements when closeAllStatements is false") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)
        stmtClosed <- Ref[IO].of(false)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit,
                  closeAllStatements = false
                )

        // Create a statement and execute query
        stmt <- proxy.createStatement()
        _    <- stmt.executeQuery("SELECT 1").attempt // Attempt to handle any errors

        // Close proxy - statements should not be closed
        _ <- proxy.close()

        // Verify we can still use the statement (would fail if closed)
        canExecute <- stmt.executeQuery("SELECT 1").attempt.map(_.isRight)
      yield assert(canExecute, "Statement should still be usable after proxy close")
    }
  }

  test("ProxyConnection should track prepared statements") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create prepared statements
        pstmt1 <- proxy.prepareStatement("SELECT ?")
        pstmt2 <- proxy.prepareStatement("SELECT ? + ?", java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY)
        pstmt3 <- proxy.prepareStatement("INSERT INTO test VALUES (?)", java.sql.Statement.RETURN_GENERATED_KEYS)

        // Use the statements
        _ <- pstmt1.setInt(1, 42)
        _ <- pstmt2.setInt(1, 10)
        _ <- pstmt2.setInt(2, 20)
        _ <- pstmt3.setString(1, "test")

        // Close proxy
        _ <- proxy.close()
      yield assert(true, "Prepared statements should be tracked and closed")
    }
  }

  test("ProxyConnection should track callable statements") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Try to create callable statements (may fail if stored procedures don't exist)
        cstmt1Result <- proxy.prepareCall("CALL test_proc()").attempt
        cstmt2Result <- proxy.prepareCall("CALL test_proc2()", java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY).attempt

        // Close proxy
        _ <- proxy.close()
      yield assert(true, "Callable statements should be tracked if created")
    }
  }

  test("ProxyConnection should handle statement close errors gracefully") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)
        errorLogged <- Ref[IO].of(false)

        // Mock statement that throws on close
        errorStmt = new Statement[IO] {
          override def close(): IO[Unit] = IO.raiseError(new RuntimeException("Close failed"))
          override def execute(sql: String): IO[Boolean] = IO.pure(false)
          override def executeQuery(sql: String): IO[ResultSet[IO]] = IO.raiseError(new UnsupportedOperationException)
          override def executeUpdate(sql: String): IO[Int] = IO.pure(0)
          override def getResultSet(): IO[Option[ResultSet[IO]]] = IO.pure(None)
          override def getUpdateCount(): IO[Int] = IO.pure(0)
          override def getMoreResults(): IO[Boolean] = IO.pure(false)
          override def setFetchSize(rows: Int): IO[Unit] = IO.unit
          override def getFetchSize(): IO[Int] = IO.pure(0)
          override def addBatch(sql: String): IO[Unit] = IO.unit
          override def clearBatch(): IO[Unit] = IO.unit
          override def executeBatch(): IO[Array[Int]] = IO.pure(Array.empty)
          override def getGeneratedKeys(): IO[ResultSet[IO]] = IO.raiseError(new UnsupportedOperationException)
          override def executeUpdate(sql: String, autoGeneratedKeys: Int): IO[Int] = IO.pure(0)
          override def execute(sql: String, autoGeneratedKeys: Int): IO[Boolean] = IO.pure(false)
          override def isClosed(): IO[Boolean] = IO.pure(false)
          override def getLargeUpdateCount(): IO[Long] = IO.pure(0L)
          override def executeLargeUpdate(sql: String): IO[Long] = IO.pure(0L)
          override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): IO[Long] = IO.pure(0L)
          override def executeLargeBatch(): IO[Array[Long]] = IO.pure(Array.empty)
        }

        // Custom console that tracks error messages
        given Console[IO] = new Console[IO] {
          def readLineWithCharset(charset: java.nio.charset.Charset): IO[String] = IO.pure("")
          def print[A](a: A)(implicit S: cats.Show[A]): IO[Unit] = IO.unit
          def println[A](a: A)(implicit S: cats.Show[A]): IO[Unit] = IO.unit
          def error[A](a: A)(implicit S: cats.Show[A]): IO[Unit] = IO.unit
          def errorln[A](a: A)(implicit S: cats.Show[A]): IO[Unit] = 
            if (S.show(a).contains("Error closing statement")) errorLogged.set(true)
            else IO.unit
        }

        // Create custom connection that returns error statements
        customConn = new LdbcConnection[IO] {
          override def createStatement(): IO[Statement[IO]] = IO.pure(errorStmt)
          override def close(): IO[Unit] = conn.close()
          override def isClosed(): IO[Boolean] = conn.isClosed()
          override def prepareStatement(sql: String): IO[PreparedStatement[IO]] = conn.prepareStatement(sql)
          override def prepareCall(sql: String): IO[CallableStatement[IO]] = conn.prepareCall(sql)
          override def nativeSQL(sql: String): IO[String] = conn.nativeSQL(sql)
          override def setAutoCommit(autoCommit: Boolean): IO[Unit] = conn.setAutoCommit(autoCommit)
          override def getAutoCommit(): IO[Boolean] = conn.getAutoCommit()
          override def commit(): IO[Unit] = conn.commit()
          override def rollback(): IO[Unit] = conn.rollback()
          override def getMetaData(): IO[DatabaseMetaData[IO]] = conn.getMetaData()
          override def setReadOnly(readOnly: Boolean): IO[Unit] = conn.setReadOnly(readOnly)
          override def isReadOnly: IO[Boolean] = conn.isReadOnly
          override def setCatalog(catalog: String): IO[Unit] = conn.setCatalog(catalog)
          override def getCatalog(): IO[String] = conn.getCatalog()
          override def setTransactionIsolation(level: Int): IO[Unit] = conn.setTransactionIsolation(level)
          override def getTransactionIsolation(): IO[Int] = conn.getTransactionIsolation()
          override def createStatement(resultSetType: Int, resultSetConcurrency: Int): IO[Statement[IO]] = IO.pure(errorStmt)
          override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, resultSetType, resultSetConcurrency)
          override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): IO[CallableStatement[IO]] = conn.prepareCall(sql, resultSetType, resultSetConcurrency)
          override def setSavepoint(): IO[Savepoint] = conn.setSavepoint()
          override def setSavepoint(name: String): IO[Savepoint] = conn.setSavepoint(name)
          override def rollback(savepoint: Savepoint): IO[Unit] = conn.rollback(savepoint)
          override def releaseSavepoint(savepoint: Savepoint): IO[Unit] = conn.releaseSavepoint(savepoint)
          override def prepareStatement(sql: String, autoGeneratedKeys: Int): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, autoGeneratedKeys)
          override def setSchema(schema: String): IO[Unit] = conn.setSchema(schema)
          override def getSchema(): IO[String] = conn.getSchema()
          override def isValid(timeout: Int): IO[Boolean] = conn.isValid(timeout)
        }

        customPooledConn <- createPooledConnection("test-3", customConn)

        proxy = new ProxyConnection[IO](
                  customPooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create statement that will fail to close
        _ <- proxy.createStatement()

        // Close should handle the error gracefully
        _ <- proxy.close()

        wasErrorLogged <- errorLogged.get
      yield assert(wasErrorLogged, "Error should have been logged")
    }
  }

  test("ProxyConnection should delegate all connection operations") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )

        // Test various delegated operations
        _          <- proxy.setAutoCommit(false)
        autoCommit <- proxy.getAutoCommit()

        catalog <- proxy.getCatalog()
        schema  <- proxy.getSchema()

        isolation <- proxy.getTransactionIsolation()
        _         <- proxy.setTransactionIsolation(java.sql.Connection.TRANSACTION_READ_COMMITTED)

        isValid  <- proxy.isValid(5)
        isClosed <- proxy.isClosed()

        metadata <- proxy.getMetaData()
        
        _           <- proxy.setAutoCommit(true)
      yield
        assert(!autoCommit, "Auto-commit should be false")
        assert(catalog != null, "Catalog should not be null")
        assert(isValid, "Connection should be valid")
        assert(!isClosed, "Connection should not be closed")
        assert(metadata != null, "Metadata should not be null")
    }
  }

  test("ProxyConnection should support transaction operations") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )

        _ <- proxy.setAutoCommit(false)

        // Create and use a statement
        stmt <- proxy.createStatement()
        _    <- stmt.executeUpdate("CREATE TEMPORARY TABLE test_proxy_tx (id INT)")
        _    <- stmt.executeUpdate("INSERT INTO test_proxy_tx VALUES (1), (2), (3)")

        // Commit the transaction
        _ <- proxy.commit()

        // Verify data was committed
        rs    <- stmt.executeQuery("SELECT COUNT(*) FROM test_proxy_tx")
        _     <- rs.next()
        count <- rs.getInt(1)

        _ <- proxy.setAutoCommit(true)
      yield assertEquals(count, 3, "Should have 3 rows after commit")
    }
  }

  test("ProxyConnection should support savepoint operations") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )

        _ <- proxy.setAutoCommit(false)

        stmt <- proxy.createStatement()
        _    <- stmt.executeUpdate("CREATE TEMPORARY TABLE test_proxy_sp (id INT)")
        
        // Insert first row
        _ <- stmt.executeUpdate("INSERT INTO test_proxy_sp VALUES (1)")
        
        // Create savepoint
        sp <- proxy.setSavepoint("sp1")
        
        // Insert second row
        _ <- stmt.executeUpdate("INSERT INTO test_proxy_sp VALUES (2)")
        
        // Rollback to savepoint
        _ <- proxy.rollback(sp)
        
        // Release savepoint
        _ <- proxy.releaseSavepoint(sp)
        
        // Commit
        _ <- proxy.commit()

        // Check results
        rs    <- stmt.executeQuery("SELECT COUNT(*) FROM test_proxy_sp")
        _     <- rs.next()
        count <- rs.getInt(1)

        _ <- proxy.setAutoCommit(true)
      yield assertEquals(count, 1, "Should have only 1 row after rollback to savepoint")
    }
  }

  test("ProxyConnection should clear statement list after close") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)
        closeCount <- Ref[IO].of(0)

        // Mock statement that counts close calls
        mockStmt = new Statement[IO] {
          override def close(): IO[Unit] = closeCount.update(_ + 1)
          override def execute(sql: String): IO[Boolean] = IO.pure(false)
          override def executeQuery(sql: String): IO[ResultSet[IO]] = IO.raiseError(new UnsupportedOperationException)
          override def executeUpdate(sql: String): IO[Int] = IO.pure(0)
          override def getResultSet(): IO[Option[ResultSet[IO]]] = IO.pure(None)
          override def getUpdateCount(): IO[Int] = IO.pure(0)
          override def getMoreResults(): IO[Boolean] = IO.pure(false)
          override def setFetchSize(rows: Int): IO[Unit] = IO.unit
          override def getFetchSize(): IO[Int] = IO.pure(0)
          override def addBatch(sql: String): IO[Unit] = IO.unit
          override def clearBatch(): IO[Unit] = IO.unit
          override def executeBatch(): IO[Array[Int]] = IO.pure(Array.empty)
          override def getGeneratedKeys(): IO[ResultSet[IO]] = IO.raiseError(new UnsupportedOperationException)
          override def executeUpdate(sql: String, autoGeneratedKeys: Int): IO[Int] = IO.pure(0)
          override def execute(sql: String, autoGeneratedKeys: Int): IO[Boolean] = IO.pure(false)
          override def isClosed(): IO[Boolean] = IO.pure(false)
          override def getLargeUpdateCount(): IO[Long] = IO.pure(0L)
          override def executeLargeUpdate(sql: String): IO[Long] = IO.pure(0L)
          override def executeLargeUpdate(sql: String, autoGeneratedKeys: Int): IO[Long] = IO.pure(0L)
          override def executeLargeBatch(): IO[Array[Long]] = IO.pure(Array.empty)
        }

        customConn = new LdbcConnection[IO] {
          override def createStatement(): IO[Statement[IO]] = IO.pure(mockStmt)
          override def close(): IO[Unit] = conn.close()
          override def isClosed(): IO[Boolean] = conn.isClosed()
          override def prepareStatement(sql: String): IO[PreparedStatement[IO]] = conn.prepareStatement(sql)
          override def prepareCall(sql: String): IO[CallableStatement[IO]] = conn.prepareCall(sql)
          override def nativeSQL(sql: String): IO[String] = conn.nativeSQL(sql)
          override def setAutoCommit(autoCommit: Boolean): IO[Unit] = conn.setAutoCommit(autoCommit)
          override def getAutoCommit(): IO[Boolean] = conn.getAutoCommit()
          override def commit(): IO[Unit] = conn.commit()
          override def rollback(): IO[Unit] = conn.rollback()
          override def getMetaData(): IO[DatabaseMetaData[IO]] = conn.getMetaData()
          override def setReadOnly(readOnly: Boolean): IO[Unit] = conn.setReadOnly(readOnly)
          override def isReadOnly: IO[Boolean] = conn.isReadOnly
          override def setCatalog(catalog: String): IO[Unit] = conn.setCatalog(catalog)
          override def getCatalog(): IO[String] = conn.getCatalog()
          override def setTransactionIsolation(level: Int): IO[Unit] = conn.setTransactionIsolation(level)
          override def getTransactionIsolation(): IO[Int] = conn.getTransactionIsolation()
          override def createStatement(resultSetType: Int, resultSetConcurrency: Int): IO[Statement[IO]] = IO.pure(mockStmt)
          override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, resultSetType, resultSetConcurrency)
          override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): IO[CallableStatement[IO]] = conn.prepareCall(sql, resultSetType, resultSetConcurrency)
          override def setSavepoint(): IO[Savepoint] = conn.setSavepoint()
          override def setSavepoint(name: String): IO[Savepoint] = conn.setSavepoint(name)
          override def rollback(savepoint: Savepoint): IO[Unit] = conn.rollback(savepoint)
          override def releaseSavepoint(savepoint: Savepoint): IO[Unit] = conn.releaseSavepoint(savepoint)
          override def prepareStatement(sql: String, autoGeneratedKeys: Int): IO[PreparedStatement[IO]] = conn.prepareStatement(sql, autoGeneratedKeys)
          override def setSchema(schema: String): IO[Unit] = conn.setSchema(schema)
          override def getSchema(): IO[String] = conn.getSchema()
          override def isValid(timeout: Int): IO[Boolean] = conn.isValid(timeout)
        }

        customPooledConn <- createPooledConnection("test-4", customConn)

        proxy = new ProxyConnection[IO](
                  customPooledConn,
                  _ => IO.unit,
                  closeAllStatements = true
                )

        // Create statements
        _ <- proxy.createStatement()
        _ <- proxy.createStatement()

        // First close
        _      <- proxy.close()
        count1 <- closeCount.get

        // Second close - statements should already be cleared
        _      <- proxy.close()
        count2 <- closeCount.get
      yield
        assertEquals(count1, 2, "First close should close 2 statements")
        assertEquals(count2, 2, "Second close should not close any additional statements")
    }
  }

  test("ProxyConnection should maintain pooled connection reference") {
    connection.use { conn =>
      for
        pooledConn <- createPooledConnection("test-1", conn)

        proxy = new ProxyConnection[IO](
                  pooledConn,
                  _ => IO.unit
                )
      yield
        assertEquals(proxy.pooled.id, "test-1")
        assertEquals(proxy.pooled, pooledConn)
    }
  }