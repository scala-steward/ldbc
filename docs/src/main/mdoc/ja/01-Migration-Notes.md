# 移行ノート

## Upgrading to 0.3.x from 0.2.x

### Packages

**パッケージ名の変更**

| 0.2.x     | 0.3.x       |
|-----------|-------------|
| ldbc-core | ldbc-schema |

**新規パッケージ**

新たに2種類のパッケージが追加されました。

| Module / Platform    | JVM | Scala Native | Scala.js |  
|----------------------|:---:|:------------:|:--------:|
| `ldbc-connector`     |  ✅  |      ✅       |    ✅     | 
| `jdbc-connector`     |  ✅  |      ❌       |    ❌     | 

**全てのパッケージ**

| Module / Platform    | JVM | Scala Native | Scala.js |  
|----------------------|:---:|:------------:|:--------:|
| `ldbc-sql`           |  ✅  |      ✅       |    ✅     |
| `ldbc-connector`     |  ✅  |      ✅       |    ✅     | 
| `jdbc-connector`     |  ✅  |      ❌       |    ❌     | 
| `ldbc-dsl`           |  ✅  |      ✅       |    ✅     |
| `ldbc-query-builder` |  ✅  |      ✅       |    ✅     |
| `ldbc-schema`        |  ✅  |      ✅       |    ✅     |
| `ldbc-schemaSpy`     |  ✅  |      ❌       |    ❌     | 
| `ldbc-codegen`       |  ✅  |      ✅       |    ✅     |
| `ldbc-hikari`        |  ✅  |      ❌       |    ❌     | 
| `ldbc-plugin`        |  ✅  |      ❌       |    ❌     |

### 機能変更

#### コネクタ切り替え機能

Scala MySQL コネクタに、JDBC と ldbc の接続切り替えのサポートが追加されました。

この変更により、開発者はプロジェクトの要件に応じて JDBC または ldbc ライブラリを使用したデータベース接続を柔軟に選択できるようになりました。これにより、開発者は異なるライブラリの機能を利用できるようになり、接続の設定や操作の柔軟性が向上します。

##### 変更方法

まず、共通の依存関係を設定する。

@@@ vars
```scala 3
libraryDependencies += "$org$" %% "ldbc-dsl" % "$version$"
```
@@@

クロスプラットフォームプロジェクトでは（JVM、JS、ネイティブ）

@@@ vars
```scala 3
libraryDependencies += "$org$" %%% "ldbc-dsl" % "$version$"
```
@@@

使用される依存パッケージは、データベース接続が Java API を使用するコネクタを介して行われるか、または ldbc によって提供されるコネクタを介して行われるかによって異なります。

**jdbcコネクタの使用**

@@@ vars
```scala 3
libraryDependencies += "$org$" %% "jdbc-connector" % "$version$"
```
@@@

**ldbcコネクタの使用**

@@@ vars
```scala 3
libraryDependencies += "$org$" %% "ldbc-connector" % "$version$"
```
@@@

クロスプラットフォームプロジェクトでは（JVM、JS、ネイティブ）

@@@ vars
```scala 3
libraryDependencies += "$org$" %%% "ldbc-connector" % "$version$"
```
@@@

##### 使用方法

**jdbcコネクタの使用**

```scala 3
val ds = new com.mysql.cj.jdbc.MysqlDataSource()
ds.setServerName("127.0.0.1")
ds.setPortNumber(13306)
ds.setDatabaseName("world")
ds.setUser("ldbc")
ds.setPassword("password")

val datasource = jdbc.connector.MysqlDataSource[IO](ds)

val connection: Resource[IO, Connection[IO]] =
  Resource.make(datasource.getConnection)(_.close())
```

**ldbcコネクタの使用**

```scala 3
val connection: Resource[IO, Connection[IO]] =
  ldbc.connector.Connection[IO](
    host     = "127.0.0.1",
    port     = 3306,
    user     = "ldbc",
    password = Some("password"),
    database = Some("ldbc"),
    ssl      = SSL.Trusted
  )
```

データベースへの接続処理は、それぞれの方法で確立されたコネクションを使って行うことができる。

```scala 3
val result: IO[(List[Int], Option[Int], Int)] = connection.use { conn =>
  (for
    result1 <- sql"SELECT 1".query[Int].to[List]
    result2 <- sql"SELECT 2".query[Int].to[Option]
    result3 <- sql"SELECT 3".query[Int].unsafe
  yield (result1, result2, result3)).readOnly(conn)
}
```

### 破壊的変更

#### プレーン・クエリ構築の拡張

プレーン・クエリを用いたデータベース接続メソッドによる検索対象の型の決定は、検索対象の型とそのフォーマット（リストまたはオプション）を一括して指定していた。

今回の修正ではこれを変更し、取得する型とその形式の指定を分離することで内部ロジックを共通化した。これにより、プレーン・クエリの構文はよりdoobieに近くなり、doobieのユーザは混乱することなく使用できるはずである。

**before**

```scala 3
sql"SELECT id, name, age FROM user".toList[(Long, String, Int)].readOnly(connection)
sql"SELECT id, name, age FROM user WHERE id = ${1L}".headOption[User].readOnly(connection)
```

**after**

```scala 3
sql"SELECT id, name, age FROM user".query[(Long, String, Int)].to[List].readOnly(connection)
sql"SELECT id, name, age FROM user WHERE id = ${1L}".query[User].to[Option].readOnly(connection)
```

#### AUTO INCREMENT値取得メソッド命名変更

更新 API で AUTO INCREMENT 列によって生成された値を変換する API `updateReturningAutoGeneratedKey` の名前が `returning` に変更されました。

これはMySQLの特徴で、MySQLはデータ挿入時にAUTO INCREMENTで生成された値を返しますが、他のRDBは動作が異なり、AUTO INCREMENTで生成された値以外の値を返すことがあります。
API 名は、将来の拡張を考慮して、限定的な API 名をより拡張しやすくするために早い段階で変更されました。

**before**

```scala 3
sql"INSERT INTO `table`(`id`, `c1`) VALUES ($None, ${ "column 1" })".updateReturningAutoGeneratedKey[Long]
```

**after**

```scala 3
sql"INSERT INTO `table`(`id`, `c1`) VALUES ($None, ${ "column 1" })".returning[Long]
```

#### クエリビルダーの構築方法

以前まではクエリビルダーはテーブルスキーマを構築しなければ使用することができませんでした。

今回の更新で、より簡易的にクエリビルダーを使用できるように変更を行いました。

**before**

まずモデルに対応したテーブルスキーマを作成し、

```scala 3
case class User(
  id: Long,
  name: String,
  age: Option[Int],
)

val userTable = Table[User]("user")(                 // CREATE TABLE `user` (
  column("id", BIGINT, AUTO_INCREMENT, PRIMARY_KEY), //   `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  column("name", VARCHAR(255)),                      //   `name` VARCHAR(255) NOT NULL,
  column("age", INT.UNSIGNED.DEFAULT(None)),         //   `age` INT unsigned DEFAULT NULL
)
```

次にテーブルスキーマを使用して`TableQuery`の構築を行います。

```scala 3
val tableQuery = TableQuery[IO, User](userTable)
```

最後にクエリ構築を行っていました。

```scala 3
val result: IO[List[User]] = connection.use { conn =>
  tableQuery.selectAll.toList[User].readOnly(conn)
  // "SELECT `id`, `name`, `age` FROM user"
}
```

**after**

今回の変更によって、モデルを構築し

```scala 3
import ldbc.query.builder.Table

case class User(
  id: Long,
  name: String,
  age: Option[Int],
) derives Table
```

次に`Table`を初期化を行います。

```scala 3
import ldbc.query.builder.Table

val userTable = Table[User]
```

最後にクエリ構築を行うことで利用可能となります。

```scala
val result: IO[List[User]] = connection.use { conn =>
  userTable.selectAll.query[User].to[List].readOnly(conn)
  // "SELECT `id`, `name`, `age` FROM user"
}
```
